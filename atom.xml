<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>汇源果汁吖！</title>
  
  <subtitle>一点小记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-07T15:16:14.850Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>hhy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>字符串到json 的错误 com.alibaba.fastjson.JSONObject cannot be cast to java.lang.String</title>
    <link href="http://yoursite.com/2020/06/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%B0json%20%E7%9A%84%E9%94%99%E8%AF%AF%20com.alibaba.fastjson.JSONObject%20cannot%20be%20cast%20to%20java.lang.String/"/>
    <id>http://yoursite.com/2020/06/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%B0json%20%E7%9A%84%E9%94%99%E8%AF%AF%20com.alibaba.fastjson.JSONObject%20cannot%20be%20cast%20to%20java.lang.String/</id>
    <published>2020-06-07T15:57:55.000Z</published>
    <updated>2020-06-07T15:16:14.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="符串到json-的错误-com-alibaba-fastjson-JSONObject-cannot-be-cast-to-java-lang-String"><a href="#符串到json-的错误-com-alibaba-fastjson-JSONObject-cannot-be-cast-to-java-lang-String" class="headerlink" title="符串到json 的错误 com.alibaba.fastjson.JSONObject cannot be cast to java.lang.String"></a>符串到json 的错误 com.alibaba.fastjson.JSONObject cannot be cast to java.lang.String</h1><p>map提取出来的对象不能转为String，而要通过它的方法 toString 来转化：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;符串到json-的错误-com-alibaba-fastjson-JSONObject-cannot-be-cast-to-java-lang-String&quot;&gt;&lt;a href=&quot;#符串到json-的错误-com-alibaba-fastjson-JSONObjec
      
    
    </summary>
    
    
      <category term="问题" scheme="http://yoursite.com/categories/%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="bug" scheme="http://yoursite.com/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>我的hexo</title>
    <link href="http://yoursite.com/2020/06/07/%E6%88%91%E7%9A%84hexo%20/"/>
    <id>http://yoursite.com/2020/06/07/%E6%88%91%E7%9A%84hexo%20/</id>
    <published>2020-06-07T14:59:52.000Z</published>
    <updated>2020-06-07T15:21:24.194Z</updated>
    
    <content type="html"><![CDATA[<p>好早以前就试过了 hexo，不过一直就是建完站就不管了，前几天写写文章出现问题：<br>title:<br>‘object Object’:null<br>然后我就重新来了一遍，顺便记录</p><a id="more"></a><h1 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h1><ul><li><p>github 创建 用户名.github.io 的仓库，添加本机 ssh 公钥</p></li><li><p>本地安装 node</p></li><li><p>npm i -g hexo 安装 hexo</p></li><li><p>hexo init 自定义根目录/ | mkdir 自定义根目录 &amp;&amp; cd 自定义根目录 &amp;&amp; hexo init</p></li><li><p>把之前的 source/_posts/目录内文件 copy 到相同路径</p></li><li><p>修改_config.yml：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">    <span class="attribute">type</span>: git</span><br><span class="line">    <span class="attribute">repository</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:han1997/han1997.github.io.git</span><br><span class="line">    <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure></li><li><p>hexo c &amp;&amp; hexo g &amp;&amp; hexo d</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">报错：</span><br><span class="line">    <span class="built_in">ERROR</span> Deployer <span class="keyword">not</span> found: git</span><br><span class="line">原因：</span><br><span class="line">    npm install --<span class="keyword">save</span> hexo-deployer-git</span><br></pre></td></tr></table></figure></li></ul><h1 id="修改样式"><a href="#修改样式" class="headerlink" title="修改样式"></a>修改样式</h1><h2 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h2><h3 id="site"><a href="#site" class="headerlink" title="site"></a>site</h3><ul><li>title 标签页显示的名字</li><li>subtitle: 副标题</li><li>description: 网站描述</li><li>keywords:</li><li>author: 作者</li><li>language: 语言</li><li>timezone: 网站时区</li></ul><h3 id="writing"><a href="#writing" class="headerlink" title="writing"></a>writing</h3><ul><li>post_asset_folder: true 文章文件夹，放图片之类</li></ul><h3 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h3><ul><li>theme: next</li></ul><h2 id="theme-next-config-yml"><a href="#theme-next-config-yml" class="headerlink" title="theme/next/_config.yml"></a>theme/next/_config.yml</h2><h3 id="menu-菜单"><a href="#menu-菜单" class="headerlink" title="menu 菜单"></a>menu 菜单</h3><h3 id="主题样式"><a href="#主题样式" class="headerlink" title="主题样式"></a>主题样式</h3><p>scheme: Gemini</p><h3 id="social-联系方式？"><a href="#social-联系方式？" class="headerlink" title="social 联系方式？"></a>social 联系方式？</h3><h3 id="toc-文章结构显示"><a href="#toc-文章结构显示" class="headerlink" title="toc 文章结构显示"></a>toc 文章结构显示</h3><h3 id="sidebar-侧栏设置"><a href="#sidebar-侧栏设置" class="headerlink" title="sidebar 侧栏设置"></a>sidebar 侧栏设置</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">sidebar:</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Sidebar Position - 侧栏位置（只对 Pisces | Gemini 两种风格有效）</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">position:</span> left <span class="comment">//靠左放置</span></span><br><span class="line"><span class="meta">#position: right <span class="comment">//靠右放置</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Sidebar Display - 侧栏显示时机（只对 Muse | Mist 两种风格有效）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#display: post <span class="comment">//默认行为，在文章页面（拥有目录列表）时显示</span></span></span><br><span class="line"><span class="symbol">display:</span> always <span class="comment">//在所有页面中都显示</span></span><br><span class="line"><span class="meta">#display: hide <span class="comment">//在所有页面中都隐藏（可以手动展开）</span></span></span><br><span class="line"><span class="meta">#display: remove <span class="comment">//完全移除</span></span></span><br><span class="line"></span><br><span class="line"><span class="symbol">offset:</span> <span class="number">12</span> <span class="comment">//文章间距（只对 Pisces | Gemini 两种风格有效）</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">b2t:</span> false <span class="comment">//返回顶部按钮（只对 Pisces | Gemini 两种风格有效）</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">scrollpercent:</span> true <span class="comment">//返回顶部按钮的百分比</span></span><br></pre></td></tr></table></figure><h3 id="Sidebar-Avatar"><a href="#Sidebar-Avatar" class="headerlink" title="Sidebar Avatar"></a>Sidebar Avatar</h3><p>avatar: /images/header.jpg<br>添加头像</p><p>###</p><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><h2 id="添加分类模块"><a href="#添加分类模块" class="headerlink" title="添加分类模块"></a>添加分类模块</h2><ol><li><p>新建一个分类页面</p><p><code>$ hexo new page categories</code></p></li><li><p>你会发现你的 source 文件夹下有了 categorcies/index.md，打开 index.md 文件将 title 设置为 title: 分类,加上 type: “categories”</p></li><li><p>打开 主题配置文件 找到 menu，将 categorcies 取消注释</p></li><li><p>把文章归入分类只需在文章的顶部标题下方添加 categories 字段，即可自动创建分类名并加入对应的分类中</p></li></ol><h2 id="添加标签模块"><a href="#添加标签模块" class="headerlink" title="添加标签模块"></a>添加标签模块</h2><ol><li><p>新建一个标签页面</p><p><code>$ hexo new page tags</code></p></li><li><p>你会发现你的 source 文件夹下有了 tags/index.md，打开 index.md 文件将 title 设置为 title: 标签，加上 type: “tags”</p></li><li><p>打开 主题配置文件 找到 menu，将 tags 取消注释</p></li><li><p>把文章添加标签只需在文章的顶部标题下方添加 tags 字段，即可自动创建标签名并归入对应的标签中</p></li></ol><h2 id="添加关于模块"><a href="#添加关于模块" class="headerlink" title="添加关于模块"></a>添加关于模块</h2><ol><li><p>新建一个关于页面</p><p><code>$ hexo new page about</code></p></li><li><p>你会发现你的 source 文件夹下有了 about/index.md，打开 index.md 文件即可编辑关于你的信息，可以随便编辑。</p></li><li><p>打开 主题配置文件 找到 menu，将 about 取消注释</p></li></ol><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><ol><li>安装插件：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-generator-<span class="keyword">search</span> <span class="comment">--save</span></span><br></pre></td></tr></table></figure><ol><li>修改站点配置文件_config.yml</li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">search:</span></span><br><span class="line"><span class="symbol">  path:</span> .<span class="meta-keyword">/public/</span>search.xml</span><br><span class="line"><span class="symbol">  field:</span> post</span><br><span class="line"><span class="symbol">  format:</span> html</span><br><span class="line"><span class="symbol">  limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure><ol><li>修改主题配置文件 theme/next/_config.yml</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line"><span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># if auto, trigger search by changing input</span></span><br><span class="line"><span class="comment"># if manual, trigger search by pressing enter key or search button</span></span><br><span class="line"><span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line"><span class="comment"># show top n results per article, show all results by setting to -1</span></span><br><span class="line"><span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="添加阅读全文按钮"><a href="#添加阅读全文按钮" class="headerlink" title="添加阅读全文按钮"></a>添加阅读全文按钮</h2><p>因为在你的博客主页会有多篇文章，如果你想让你的文章只显示一部分，多余的可以点击阅读全文来查看，那么你需要在你的文章中添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--more--&gt;</span></span><br></pre></td></tr></table></figure><p>其后面的部分就不会显示了，只能点击阅读全文才能看</p><h2 id="修改文章内链接文本样式"><a href="#修改文章内链接文本样式" class="headerlink" title="修改文章内链接文本样式"></a>修改文章内链接文本样式</h2><p>打开文件 themes/next/source/css/_common/components/post/post.styl，在末尾添加</p><p><code>.post-body p a { color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover { color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; } }</code><br>其中选择 .post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。</p><h2 id="设置网站缩略图标"><a href="#设置网站缩略图标" class="headerlink" title="设置网站缩略图标"></a>设置网站缩略图标</h2><p>把 favicon.ico 放到站点目录的 source 目录下</p><h2 id="设置-RSS"><a href="#设置-RSS" class="headerlink" title="设置 RSS"></a>设置 RSS</h2><ol><li>先安装 hexo-generator-feed 插件</li></ol><blockquote><p>npm install hexo-generator-feed –save</p></blockquote><ol><li>打开 站点配置文件 找到 Extensions 在下面添加</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RSS 订阅</span></span><br><span class="line"></span><br><span class="line"><span class="attr">feed:</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line"><span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line"><span class="attr">limit:</span> <span class="number">20</span></span><br><span class="line"><span class="attr">hub:</span></span><br><span class="line"><span class="attr">content:</span></span><br><span class="line"><span class="attr">content_limit:</span> <span class="number">140</span></span><br><span class="line"><span class="attr">content_limit_delim:</span> <span class="string">' '</span></span><br></pre></td></tr></table></figure><ol><li><p>打开 主题配置文件 找到 rss，设置为</p><blockquote><p>rss: /atom.xml</p></blockquote></li></ol><h2 id="添加评论系统"><a href="#添加评论系统" class="headerlink" title="添加评论系统"></a>添加评论系统</h2><ol><li>进入友言官网注册、登录步骤我就不介绍了</li><li>登录完成之后，点击获取代码，你会发现出来了一段代码，里面有你的 uid=1234567</li><li>打开 主题配置文件 找到 youyan_uid 将值设置为上面的 uid 就可以了</li></ol><h2 id="添加站点访问计数"><a href="#添加站点访问计数" class="headerlink" title="添加站点访问计数"></a>添加站点访问计数</h2><p>不蒜子<a href="http://busuanzi.ibruce.info]/">[http://busuanzi.ibruce.info]</a></p><ol><li>安装脚本<br>打开 themes/next/layout/_partial/footer.swig，将下面这段代码添加到里面</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_site_pv"</span> <span class="attr">style</span>=<span class="string">'display:none'</span>&gt;</span></span><br><span class="line">  本站总访问量 <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_pv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> 次</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-divider"</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_site_uv"</span> <span class="attr">style</span>=<span class="string">'display:none'</span>&gt;</span></span><br><span class="line">  有<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_uv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>人看过我的博客啦</span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加的位置如下图，可自行根据个人喜好更换位置</p><ol><li>以上只是显示站点的访问次数，如果想显示每篇文章的访问次数，打开 themes/next/layout/_macro/post.swig，在第一行增加 is_pv 字段</li></ol><figure class="highlight twig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">`</span><span class="template-tag">&#123;% <span class="name"><span class="keyword">macro</span></span> render(post, is_index, is_pv, post_extra_class) %&#125;</span><span class="xml">`</span></span><br><span class="line"></span><br><span class="line"><span class="xml">然后将这段代码插入到里面</span></span><br><span class="line"></span><br><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="keyword">if</span></span> is_pv %&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-divider"</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span>`</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_page_pv"</span>&gt;</span>`</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span>次阅读 </span><span class="template-tag">&#123;% <span class="name"><span class="keyword">endif</span></span> %&#125;</span></span><br></pre></td></tr></table></figure><p>插入的位置</p><p>然后再打开 themes/next/layout/post.swig，这个文件是文章的模板，给 render 方法传入参数（对应刚才添加的 is_pv 字段）<br>最后再打开 themes/next/layout/index.swig，这个文件是首页的模板，给 render 方法传入参数（对应刚才添加的 is_pv 字段）<br>OK！设置完毕。</p><h2 id="去掉文章目录标题的自动编号"><a href="#去掉文章目录标题的自动编号" class="headerlink" title="去掉文章目录标题的自动编号"></a>去掉文章目录标题的自动编号</h2><p>我们自己写文章的时候一般都会自己带上标题编号，但是默认的主题会给我们带上编号，很是别扭，如何去掉呢？<br>打开主题配置文件，找到将 number 改为 false 即可</p><h2 id="添加-cdn-加速"><a href="#添加-cdn-加速" class="headerlink" title="添加 cdn 加速"></a>添加 cdn 加速</h2><p>vendors 下取消注释即可</p><h2 id="网站动态元素延时加载"><a href="#网站动态元素延时加载" class="headerlink" title="网站动态元素延时加载"></a>网站动态元素延时加载</h2><p>motion:<br>enable:false</p><p>我还打开了，不记得在哪里看到的了<br>背景有效果了<br>canvas_nest:<br>enable: true</p><h2 id="增加文章置顶功能"><a href="#增加文章置顶功能" class="headerlink" title="增加文章置顶功能"></a>增加文章置顶功能</h2><p>修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">'hexo-pagination'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = <span class="keyword">this</span>.config;</span><br><span class="line">  <span class="keyword">var</span> posts = locals.posts;</span><br><span class="line">    posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.top &amp;&amp; b.top) &#123; <span class="comment">// 两篇文章top都有定义</span></span><br><span class="line">            <span class="keyword">if</span>(a.top == b.top) <span class="keyword">return</span> b.date - a.date; <span class="comment">// 若top值一样则按照文章日期降序排</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> b.top - a.top; <span class="comment">// 否则按照top值降序排</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a.top &amp;&amp; !b.top) &#123; <span class="comment">// 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> b.date - a.date; <span class="comment">// 都没定义按照文章日期降序排</span></span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">var</span> paginationDir = config.pagination_dir || <span class="string">'page'</span>;</span><br><span class="line">  <span class="keyword">return</span> pagination(<span class="string">''</span>, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [<span class="string">'index'</span>, <span class="string">'archive'</span>],</span><br><span class="line">    format: paginationDir + <span class="string">'/%d/'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在文章中添加 top 值，数值越大文章越靠前，如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">解决Charles乱码问题</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2017</span><span class="number">-05</span><span class="number">-22</span> <span class="number">22</span><span class="string">:45:48</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">技巧</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">技巧</span></span><br><span class="line"><span class="attr">copyright:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">top:</span> <span class="number">100</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p><strong>少量图片</strong><br>当 Hexo 项目中只用到少量图片时，可以将图片统一放在 source/images 文件夹中，通过 markdown 语法访问它们。对于 source/images/image.jpg 这张图片可以用以下语法访问到<br><code>![](/images/image.jpg)</code></p><p><strong>大量图片</strong><br>修改_config.yml 配置文件 post_asset_folder 项为 true。<br>在 source/_post 文件夹里面就会出现一个“这是一个新的博客.md”的文件和一个“这是一个新的博客”的文件夹。<br>把需要的图片放到新创建的那个文件夹里面去。</p><p>``</p><h2 id="设置文章字体的颜色、大小"><a href="#设置文章字体的颜色、大小" class="headerlink" title="设置文章字体的颜色、大小"></a>设置文章字体的颜色、大小</h2><p>如果想设置某一句的颜色或大小，只需用 html 语法写出来就行了</p><p>我可以设置这一句的颜色哈哈</p><p>我还可以设置这一句的大小嘻嘻</p><p>我甚至可以设置这一句的颜色和大小呵呵</p><h2 id="设置文字居中"><a href="#设置文字居中" class="headerlink" title="设置文字居中"></a>设置文字居中</h2><p>居中</p><p>借鉴原文[<a href="http://www.360doc.com/content/19/0418/20/22888630_829741117.shtml]" target="_blank" rel="noopener">http://www.360doc.com/content/19/0418/20/22888630_829741117.shtml]</a><br>借鉴原文[<a href="https://blog.csdn.net/nightmare_dimple/article/details/86661505]" target="_blank" rel="noopener">https://blog.csdn.net/nightmare_dimple/article/details/86661505]</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好早以前就试过了 hexo，不过一直就是建完站就不管了，前几天写写文章出现问题：&lt;br&gt;title:&lt;br&gt;‘object Object’:null&lt;br&gt;然后我就重新来了一遍，顺便记录&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂项" scheme="http://yoursite.com/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>算法的时间复杂度与空间复杂度</title>
    <link href="http://yoursite.com/2020/06/07/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%20/"/>
    <id>http://yoursite.com/2020/06/07/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%20/</id>
    <published>2020-06-07T14:58:12.000Z</published>
    <updated>2020-06-07T15:21:37.124Z</updated>
    
    <content type="html"><![CDATA[<p>摘录地址[<a href="https://blog.csdn.net/jsjwk/article/details/84315770]" target="_blank" rel="noopener">https://blog.csdn.net/jsjwk/article/details/84315770]</a></p><p>算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。</p><p>如何去衡量不同算法之间的优劣呢？</p><ul><li>时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。</li><li>空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。</li></ul><p>评价一个算法的效率主要是看它的时间复杂度和空间复杂度情况。然而，有的时候时间和空间却又是「鱼和熊掌」，不可兼得的，那么我们就需要从中去取一个平衡点。</p><a id="more"></a><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><blockquote><p>「 大 O 符号表示法 」，即 T(n) = O(f(n))</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">i</span>=<span class="number">1</span>; <span class="built_in">i</span>&lt;=n; ++<span class="built_in">i</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">j</span> = <span class="built_in">i</span>;</span><br><span class="line">   <span class="built_in">j</span>++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：算法的渐进时间复杂度。</p><p>假设每行代码的执行时间都是一样的，我们用 1 颗粒时间 来表示，那么这个例子的第一行耗时是 1 个颗粒时间，第三行的执行时间是 n 个颗粒时间，第四行的执行时间也是 n 个颗粒时间（第二行和第五行是符号，暂时忽略），那么总时间就是 1 颗粒时间 + n 颗粒时间 + n 颗粒时间 ，即 (1+2n)个颗粒时间，即： T(n) = (1+2n)*颗粒时间，从这个结果可以看出，这个算法的耗时是随着 n 的变化而变化，因此，我们可以简化的将这个算法的时间复杂度表示为：T(n) = O(n)</p><p>大 O 符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。</p><p>所以上面的例子中，如果 n 无限大的时候，T(n) = time(1+2n)中的常量 1 就没有意义了，倍数 2 也意义不大。因此直接简化为 T(n) = O(n) 就可以了。</p><ul><li>常见的时间复杂度量级有：</li><li>常数阶 O(1)</li><li>对数阶 O(logN)</li><li>线性阶 O(n)</li><li>线性对数阶 O(nlogN)</li><li>平方阶 O(n²)</li><li>立方阶 O(n³)</li><li>K 次方阶 O(n^k)</li><li>指数阶(2^n)</li></ul><p>上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。</p><h2 id="常数阶-O-1"><a href="#常数阶-O-1" class="headerlink" title="常数阶 O(1)"></a>常数阶 O(1)</h2><p>只要是没有循环等复杂结构，那这个代码的时间复杂度就都是 O(1)</p><h2 id="线性阶-O-n"><a href="#线性阶-O-n" class="headerlink" title="线性阶 O(n)"></a>线性阶 O(n)</h2><p>(1 个)for 循环里面的代码会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化的，因此这类代码都可以用 O(n)来表示它的时间复杂度。</p><h2 id="对数阶-O-logN"><a href="#对数阶-O-logN" class="headerlink" title="对数阶 O(logN)"></a>对数阶 O(logN)</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int <span class="built_in">i</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">i</span>&lt;n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">i</span> = <span class="built_in">i</span> * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 while 循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环 x 次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n<br>也就是说当循环 log2^n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(logn)</p><h2 id="线性对数阶-O-nlogN"><a href="#线性对数阶-O-nlogN" class="headerlink" title="线性对数阶 O(nlogN)"></a>线性对数阶 O(nlogN)</h2><p>线性对数阶 O(nlogN) 其实非常容易理解，将时间复杂度为 O(logn)的代码循环 N 遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了 O(nlogN)。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(m=<span class="number">1</span>; m&lt;n; m++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">i</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">i</span>&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">i</span> = <span class="built_in">i</span> \* <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平方阶-O-n²"><a href="#平方阶-O-n²" class="headerlink" title="平方阶 O(n²)"></a>平方阶 O(n²)</h2><p>如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。<br>举例：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(x=<span class="number">1</span>; <span class="built_in">i</span>&lt;=n; x++)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="built_in">i</span>=<span class="number">1</span>; <span class="built_in">i</span>&lt;=n; <span class="built_in">i</span>++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">j</span> = <span class="built_in">i</span>;</span><br><span class="line">       <span class="built_in">j</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码其实就是嵌套了 2 层 n 循环，它的时间复杂度就是 O(n*n)，即 O(n²)</p><h2 id="立方阶-O-n³-、K-次方阶-O-n-k"><a href="#立方阶-O-n³-、K-次方阶-O-n-k" class="headerlink" title="立方阶 O(n³)、K 次方阶 O(n^k)"></a>立方阶 O(n³)、K 次方阶 O(n^k)</h2><p>O(n³)相当于三层 n 循环，其它的类似</p><h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><p>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。</p><p>空间复杂度比较常用的有：O(1)、O(n)、O(n²)，我们下面来看看：</p><h2 id="空间复杂度-O-1"><a href="#空间复杂度-O-1" class="headerlink" title="空间复杂度 O(1)"></a>空间复杂度 O(1)</h2><p>如果算法执行所需要的临时空间不随着某个变量 n 的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)<br>举例：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int <span class="built_in">i</span> = <span class="number">1</span>;</span><br><span class="line">int <span class="built_in">j</span> = <span class="number">2</span>;</span><br><span class="line">++<span class="built_in">i</span>;</span><br><span class="line"><span class="built_in">j</span>++;</span><br><span class="line">int m = <span class="built_in">i</span> + <span class="built_in">j</span>;</span><br></pre></td></tr></table></figure><p>代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)</p><h2 id="空间复杂度-O-n"><a href="#空间复杂度-O-n" class="headerlink" title="空间复杂度 O(n)"></a>空间复杂度 O(n)</h2><p>我们先看一个代码：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int[] m = new int[n]</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">i</span>=<span class="number">1</span>; <span class="built_in">i</span>&lt;=n; ++<span class="built_in">i</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">j</span> = <span class="built_in">i</span>;</span><br><span class="line">   <span class="built_in">j</span>++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，第一行 new 了一个数组出来，这个数据占用的大小为 n，这段代码的 2-6 行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘录地址[&lt;a href=&quot;https://blog.csdn.net/jsjwk/article/details/84315770]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/jsjwk/article/details/84315770]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。&lt;/p&gt;
&lt;p&gt;如何去衡量不同算法之间的优劣呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。&lt;/li&gt;
&lt;li&gt;空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;评价一个算法的效率主要是看它的时间复杂度和空间复杂度情况。然而，有的时候时间和空间却又是「鱼和熊掌」，不可兼得的，那么我们就需要从中去取一个平衡点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="进阶" scheme="http://yoursite.com/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数组实现邻接表</title>
    <link href="http://yoursite.com/2020/06/07/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%82%BB%E6%8E%A5%E8%A1%A8%20/"/>
    <id>http://yoursite.com/2020/06/07/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%82%BB%E6%8E%A5%E8%A1%A8%20/</id>
    <published>2020-06-07T14:58:10.000Z</published>
    <updated>2020-06-07T15:20:21.598Z</updated>
    
    <content type="html"><![CDATA[<p>图有邻接矩阵存储法，时间和空间复杂度都是 N2，还有另一种存储图的方法-邻接表，它的时间和空间复杂度都是 m。对于稀疏图来说，m 要远远小于 n 的平方。</p><p>tip:</p><p>边数 M &lt; 顶点数 N^2 –&gt;稀疏图 –&gt;可用邻接表<br>边数 M &gt; 顶点数 N^2 –&gt;稠密图</p><h1 id="数据："><a href="#数据：" class="headerlink" title="数据："></a>数据：</h1><p>输入:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">4 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">4</span> <span class="number">9</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">3</span> <span class="number">8</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><p>第 1 行，两个整数 n,m，N 表示顶点个数，顶点编号为 1~n，m 表示边的个数。接下来 m 行表示每行有三个数，xyz 表示顶点 x 到顶点 y 的边的权值为 z。</p><p>按照读入的顺序为每一条边进行编号，1~m。比如第 1 条边 149 的编号就是 1， 137 这条边的编号是 5。</p><p>用 uvw 三个数组来记录每条边的具体信息。U[i]v[i] 和 w[i] 表示第 i 边是从第 u[i] 号顶点到 v[i] 号顶点，权值为 w[i]。</p><p>再用一个 first 数组来存储每个顶点其中(任意)一条边的编号。以便将来我们枚举每个顶点所有的边。比如 1 号顶点有一条边是 149，那么就将 first1 的值设为 1。如果某个顶点没有以该顶点为起始点的边，则将 first[i] 的值设为-1。</p><p>读入第 1 条边 149，将这条边的信息存储到 u[1],v[1],w[1] 中。同时为这条边赋予一个编号，因为这条边是最先读入的，存储在 u,v 和 w 数组下标为 1 的单元格中，因此编号就是 1。这条边的起始点是 1 号顶点，因此将 first[1] 的值设为 1。</p><p>这条编号为 1 的边是以 1 号顶点为起始点的第 1 条边，所以要将 next[1] 的值设为-1。也就是说如果当前这条编号为 i 的边，是我们发现的以 u[i] 为起点的第 1 条边就将 next [i] 的值设为-1。</p><p>读入第 2 条边 438，将这条边的信息存储到 u[2],v[2] 和 w[2]中，这条边的编号为 2，这条边的起始顶点是 4 号顶点，因此将 first[4] 的值设为 2，另外这条编号为 2 的边是我们发现以 4 号起点为起始点的第 1 条边，所以将 next[2] 的值设为-1。</p><p>读入第 3 条边 125，将这条边的信息存储到 u[3]v[3] 和 w[3]中，这条边的编号为 3，起始顶点是 1 号顶点，我们发现 1 号顶点已经有一条编号为一的边了，如果此时将 first[1] 的值设为 3 那编号唯一的边岂不是丢失了，此时只需将 next[3] 的值设为 1。</p><p><strong><em>Next 数组存储的是编号为 i 的边的前一条边的编号\</em></strong></p><p>读入第 4 条边 246，将这条边的信息存储到 u[4]v[4] 和 w[4]中，这条边的编号为 4，起始顶点是 2 号顶点，因此将 first[2] 的值设为 4，另外这条编号为 4 的边是我们发现以 2 号顶点为起始点的第 1 条边，所以将 next[4] 的值设为-1。</p><p>读入第 5 条边 137，将这条边的信息存储到 u[5]v[5] 和 w[5]中，这条边的编号为 5，起始顶点又是 1 号顶点，此时需要将 first[1] 的值设为 5，并将 next[5] 的值改为 3。</p><p>1 号顶点的其中一条边的编号存储在 first 一中，其余的边可以通过 next 数组找到。</p><p><strong><em>此时遍历某个顶点边的时候的遍历顺序，正好与读入时候的顺序相反。因为在为每个顶点插入边的时候，都是直接插入链表的手部，而不是尾部。\</em></strong></p><p>创建连接表的代码：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> n,m,i;</span><br><span class="line"><span class="comment">//u、v和w的数组大小要根据实际情况来设置，要比m的最大值要大1</span></span><br><span class="line"><span class="built_in">int</span> u[<span class="number">6</span>],v[<span class="number">6</span>],w[<span class="number">6</span>];</span><br><span class="line"><span class="comment">//first和next的数组大小要根据实际情况来设置，要比n的最大值要大1</span></span><br><span class="line"><span class="built_in">int</span> first[<span class="number">5</span>],next[<span class="number">5</span>];</span><br><span class="line">scanf(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="comment">//初始化first数组下标1~n的值为-1，表示1~n顶点暂时都没有边</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    first[i]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">    scanf(<span class="string">"%d %d %d"</span>,&amp;u[i],&amp;v[i],&amp;w[i]);<span class="comment">//读入每一条边</span></span><br><span class="line">    <span class="comment">//下面两句是关键啦</span></span><br><span class="line">    next[i]=first[u[i]];</span><br><span class="line">    first[u[i]]=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历 1 号顶点所有边的代码:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">k=first[<span class="number">1</span>];<span class="regexp">//</span> <span class="number">1</span>号顶点其中的一条边的编号（其实也是最后读入的边）</span><br><span class="line"><span class="keyword">while</span>(k!=-<span class="number">1</span>) //其余的边都可以在<span class="keyword">next</span>数组中依次找到</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"%d %d %d\n"</span>,u[k],v[k],w[k]);</span><br><span class="line">    k=<span class="keyword">next</span>[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历每个顶点的所有边的代码:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="attribute">i</span>=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">k</span>=first[i];</span><br><span class="line">    <span class="keyword">while</span>(k!=-1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">"%d %d %d\n"</span>,u[k],v[k],w[k]);</span><br><span class="line">        <span class="attribute">k</span>=next[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考原文[<a href="http://developer.51cto.com/art/201404/435072.htm]" target="_blank" rel="noopener">http://developer.51cto.com/art/201404/435072.htm]</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;图有邻接矩阵存储法，时间和空间复杂度都是 N2，还有另一种存储图的方法-邻接表，它的时间和空间复杂度都是 m。对于稀疏图来说，m 要远远小于 n 的平方。&lt;/p&gt;
&lt;p&gt;tip:&lt;/p&gt;
&lt;p&gt;边数 M &amp;lt; 顶点数 N^2 –&amp;gt;稀疏图 –&amp;gt;可用邻接表&lt;br
      
    
    </summary>
    
    
      <category term="进阶" scheme="http://yoursite.com/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>人生思考</title>
    <link href="http://yoursite.com/2020/06/07/%E4%BA%BA%E7%94%9F%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2020/06/07/%E4%BA%BA%E7%94%9F%E6%80%9D%E8%80%83/</id>
    <published>2020-06-07T14:58:01.000Z</published>
    <updated>2020-06-07T15:18:56.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="人生思考"><a href="#人生思考" class="headerlink" title="人生思考"></a>人生思考</h1><ul><li>1个ACSII  1个字节，(int) 1 (4字节)–&gt; ACSII </li></ul><ul><li>char 基本数据类型 2字节</li><li>String 占字节数与编码有关 —— &gt;<ul><li>使用GBK时  英文字符 1字节，中文字符 2字节</li><li>使用UTF-8时  英文字符 1字节，中文字符 3字节</li><li>使用unicode时  全都是 4字节</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;人生思考&quot;&gt;&lt;a href=&quot;#人生思考&quot; class=&quot;headerlink&quot; title=&quot;人生思考&quot;&gt;&lt;/a&gt;人生思考&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1个ACSII  1个字节，(int) 1 (4字节)–&amp;gt; ACSII &lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;

      
    
    </summary>
    
    
      <category term="问题" scheme="http://yoursite.com/categories/%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="思考" scheme="http://yoursite.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>启动MySQL遇到错误</title>
    <link href="http://yoursite.com/2020/06/07/%E5%90%AF%E5%8A%A8MySQL%E9%81%87%E5%88%B0%E9%94%99%E8%AF%AF%20/"/>
    <id>http://yoursite.com/2020/06/07/%E5%90%AF%E5%8A%A8MySQL%E9%81%87%E5%88%B0%E9%94%99%E8%AF%AF%20/</id>
    <published>2020-06-07T14:58:00.000Z</published>
    <updated>2020-06-07T15:18:13.277Z</updated>
    
    <content type="html"><![CDATA[<p>具体情况：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ mysql -uroot -p</span><br><span class="line">Enter password:</span><br><span class="line"><span class="keyword">ERROR </span>2002 (HY000): Can't connect to local MySQL server through socket '/tmp/mysql.sock' (2)</span><br></pre></td></tr></table></figure><p>解决：转载博客—-&gt;</p><blockquote><p>只是前几天将 Mac 的系统升级到了 10.14.2 顺着提示的错误进入到 tmp 文件夹发现没有 mysql.sock 文件,最后查询发现有人说道可能是因为：mac 系统版本的问题.因为 Mac OS X 的升级或其他原因会导致Ｍ ySQL 启动或开机自动运行时/usr/local/mysql/data 的宿主发生了改变，没有了这个文件夹的权限了。<br>在终端输入，并输入 root 密码：</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R mysql <span class="regexp">/usr/</span>local<span class="regexp">/mysql/</span>data</span><br></pre></td></tr></table></figure><p>此时进入到 tmp 下会自动生成 mysql.sock</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  / tmp</span><br><span class="line">➜  /tmp ls</span><br><span class="line">AlTest1<span class="selector-class">.err</span>                  mysql<span class="selector-class">.sock</span>.lock</span><br><span class="line">AlTest1<span class="selector-class">.out</span>                  mysqlx.sock</span><br><span class="line">com<span class="selector-class">.apple</span><span class="selector-class">.launchd</span><span class="selector-class">.JzjnOhtY6W</span> mysqlx<span class="selector-class">.sock</span>.lock</span><br><span class="line">com<span class="selector-class">.apple</span><span class="selector-class">.launchd</span><span class="selector-class">.W2xJKVPDzB</span> powerlog</span><br><span class="line">mysql.sock</span><br></pre></td></tr></table></figure><hr><p>作者：zhangvalue<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/zhangvalue/article/details/89310982" target="_blank" rel="noopener">https://blog.csdn.net/zhangvalue/article/details/89310982</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;具体情况：&lt;/p&gt;
&lt;figure class=&quot;highlight subunit&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;
      
    
    </summary>
    
    
      <category term="项目" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="毕设" scheme="http://yoursite.com/tags/%E6%AF%95%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>面试问题小记录</title>
    <link href="http://yoursite.com/2020/06/07/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%B0%8F%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/06/07/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%B0%8F%E8%AE%B0%E5%BD%95/</id>
    <published>2020-06-07T14:57:59.000Z</published>
    <updated>2020-06-07T15:17:51.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="J2EE"><a href="#J2EE" class="headerlink" title="J2EE"></a>J2EE</h1><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p><strong>GET/POST</strong></p><ol><li><p>GET/POST <a href="https://www.zhihu.com/question/28586791" target="_blank" rel="noopener">逼乎文章</a></p><ol><li><p>浏览器上的get和post</p><ul><li><p>get用来获取浏览器上的资源</p></li><li><p>post用来向服务器发起一个请求/表单</p></li></ul></li><li><p>接口中的get/post  或者可以说是REST中的get/post</p></li><li><p>安全性–本质上都是http协议，都不安全</p></li></ol></li><li><p>REST是什么？</p><ol><li>1</li></ol></li><li><p>HTTP协议</p><ol><li>1</li><li>2</li></ol></li><li><p>POST的幂等是什么意思？</p></li></ol><p><strong>转发(Forward)和重定向(Redirect)的区别</strong></p><ol><li>简单来说<ul><li>转发：服务器行为，使用RequestDisPatcher.forward(request,response)实现</li><li>重定向：客户端行为，浏览器返回状态码301/302，浏览器到新网址重新请求该资源</li></ul></li><li>2</li></ol><p><strong><code>request.getAttribute()</code>和 <code>request.getParameter()</code>有何区别</strong></p><p><code>getParameter()</code>返回的是String,用于读取提交的表单中的值;（获取之后会根据实际需要转换为自己需要的相应类型，比如整型，日期类型啊等等）</p><p><code>getAttribute()</code>返回的是Object，需进行转换,可用<code>setAttribute()</code>设置成任意对象，使用很灵活，可随时用</p><p><strong>Cookie和Session的区别</strong></p><ul><li>Cookie：一般用来保存用户信息，保存在客户端</li><li>Session：通过服务端记录用户状态，保存在服务端，相对更加安全</li></ul><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><ol><li><p>什么时候用枚举？</p><ul><li>订单状态：未支付，已付款，已完成</li><li>接口返回信息：成功，失败</li><li>异常信息：</li></ul></li><li><p>使用 == 比较枚举值不容易出错</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PizzaStatus status;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> PizzaStatus &#123;</span><br><span class="line">        ORDERED,</span><br><span class="line">        READY,</span><br><span class="line">        DELIVERED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDeliverable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getStatus() == PizzaStatus.READY) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Methods that set and get the status variable.</span></span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------</span><br></pre></td></tr></table></figure></li><li></li></ol><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><ol><li>HashMap<ol><li>HashMap对比HashTable线程不安全，HashTable已经不再使用，需要线程安全的话使用ConcurrentHashMap</li><li>HashMap链表长度大于阈值自动转化数据结构为红黑树</li></ol></li></ol><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;J2EE&quot;&gt;&lt;a href=&quot;#J2EE&quot; class=&quot;headerlink&quot; title=&quot;J2EE&quot;&gt;&lt;/a&gt;J2EE&lt;/h1&gt;&lt;h2 id=&quot;Servlet&quot;&gt;&lt;a href=&quot;#Servlet&quot; class=&quot;headerlink&quot; title=&quot;Ser
      
    
    </summary>
    
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>记录一次session做登录记录，写拦截器做权限验证时遇到的问题</title>
    <link href="http://yoursite.com/2020/06/07/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1session%E5%81%9A%E7%99%BB%E5%BD%95%E8%AE%B0%E5%BD%95%EF%BC%8C%E5%86%99%E6%8B%A6%E6%88%AA%E5%99%A8%E5%81%9A%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/06/07/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1session%E5%81%9A%E7%99%BB%E5%BD%95%E8%AE%B0%E5%BD%95%EF%BC%8C%E5%86%99%E6%8B%A6%E6%88%AA%E5%99%A8%E5%81%9A%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-06-07T14:57:58.000Z</published>
    <updated>2020-06-07T15:17:15.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记录一次session做登录记录，写拦截器做权限验证时遇到的问题"><a href="#记录一次session做登录记录，写拦截器做权限验证时遇到的问题" class="headerlink" title="记录一次session做登录记录，写拦截器做权限验证时遇到的问题"></a>记录一次session做登录记录，写拦截器做权限验证时遇到的问题</h1><h2 id="问题发生前提"><a href="#问题发生前提" class="headerlink" title="问题发生前提"></a>问题发生前提</h2><ol><li>登录之后写session作为登录状态记录</li><li>写拦截器拦截所以请求</li><li>某些接口有自定义注解@loginrequired(require=””,role=?)</li><li>当required为ture，必须要登录，role为用户权限，低于某种权限不允许访问</li></ol><h2 id="具体问题"><a href="#具体问题" class="headerlink" title="具体问题"></a>具体问题</h2><ol><li>跨域问题</li><li>login、logout接口可以正常使用sessionid一致，get即权限验证接口sessionid不一致</li></ol><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ol><li><p>跨域</p><ol><li><p>在继承HandlerInterceptorAdapter的子类拦截器的preHandle方法里面对response设置header：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        请求跨域</span></span><br><span class="line">        response.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, request.getHeader(<span class="string">"Origin"</span>));</span><br><span class="line"><span class="comment">//        response.setHeader("Access-Control-Allow-Origin", "*");</span></span><br><span class="line">        <span class="comment">// 允许携带 用户认证凭据（也就是允许客户端发送的请求携带Cookie）</span></span><br><span class="line">        response.setHeader(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="string">"true"</span>);</span><br><span class="line">        response.setHeader(<span class="string">"Access-Control-Allow-Methods"</span>, <span class="string">"POST, GET, PATCH, DELETE, PUT"</span>);</span><br><span class="line">        response.setHeader(<span class="string">"Access-Control-Max-Age"</span>, <span class="string">"3600"</span>);</span><br><span class="line">        response.setHeader(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"Origin, X-Requested-With, Content-Type, Accept"</span>);</span><br></pre></td></tr></table></figure></li><li><p>在WebMvcConfigurer实现类webConfig里面重写对跨域的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置跨域访问</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">"/**"</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">"*"</span>)</span><br><span class="line">                .allowedMethods(<span class="string">"GET"</span>, <span class="string">"HEAD"</span>, <span class="string">"POST"</span>, <span class="string">"PUT"</span>, <span class="string">"PATCH"</span>, <span class="string">"DELETE"</span>, <span class="string">"OPTIONS"</span>, <span class="string">"TRACE"</span>)</span><br><span class="line">            <span class="comment">// 允许携带 用户认证凭据（也就是允许客户端发送的请求携带Cookie）</span></span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>直接在方法上面使用@CrossOrigin注解</p></li><li><p>客户端请求的时候需要携带Cookie，也就是下面一个问题了</p></li></ol></li><li><p>客户端请求是携带身份验证</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">            url: <span class="string">"http://127.0.0.1:8080/sys/user/get"</span>,</span><br><span class="line">            method: <span class="string">"POST"</span>,</span><br><span class="line">            data: userName,</span><br><span class="line">    <span class="comment">//携带cookie</span></span><br><span class="line">            xhrFields: &#123;</span><br><span class="line">                withCredentials: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(data);</span><br><span class="line">            &#125;,</span><br><span class="line">            error: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"error："</span> + data.data);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;记录一次session做登录记录，写拦截器做权限验证时遇到的问题&quot;&gt;&lt;a href=&quot;#记录一次session做登录记录，写拦截器做权限验证时遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;记录一次session做登录记录，写拦截器做权限验证时遇
      
    
    </summary>
    
    
      <category term="问题" scheme="http://yoursite.com/categories/%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="bug" scheme="http://yoursite.com/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>谷粒商城</title>
    <link href="http://yoursite.com/2020/06/07/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8EV2.0/"/>
    <id>http://yoursite.com/2020/06/07/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8EV2.0/</id>
    <published>2020-06-07T14:57:57.000Z</published>
    <updated>2020-06-07T15:16:50.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="电商项目了解一下"><a href="#电商项目了解一下" class="headerlink" title="电商项目了解一下"></a>电商项目了解一下</h3><ul><li>访问量大</li><li>数据量大</li><li>并发高</li><li>业务复杂，技术点多</li></ul><h3 id="电商分类"><a href="#电商分类" class="headerlink" title="电商分类"></a>电商分类</h3><ul><li>B2C – Business To Consumer</li></ul><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><h3 id="分布式了解一下"><a href="#分布式了解一下" class="headerlink" title="分布式了解一下"></a>分布式了解一下</h3><blockquote><p>单一架构</p></blockquote><p>—&gt;小型网站，小型管理系统，功能简单</p><blockquote><p>垂直应用架构</p></blockquote><p>–&gt;切分业务</p><blockquote><p>分布式</p></blockquote><p>–&gt;把各个应用通过分层独立出来，利用RPC实现web与service，service与service之间的相互调用，提高了代码的复用性</p><blockquote><p>面向服务的分布式架构</p></blockquote><p>用一个统一的应用中心来调度、路由、管理所有的服务。基于这个中心构建的星型架构又叫做 SOA分布式架构</p><p><strong>如何实现SOA架构<br></strong></p><p><del>以前的controller，service，serviceImpl都在一个工程里面，通过Spring的IOC完成相互调用</del></p><p>IDEA 在项目里面建立module</p><ol><li>maven项目parent作为项目的主基石，确定项目的SpringBoot版本以及所有的版本控制，在其他所有项目通过<parent>标签引入</li><li>maven项目api作为（interface）接口、bean存在的项目，所有项目通过<dependecy>引入</li><li>maven项目common-util作为公共工具类，在其中引用通用的工具类依赖</li><li>maven项目web-util作为前段依赖引入项目</li><li>amven项目service-util作为后端服务依赖引入项目</li></ol><h3 id="dubbo"><a href="#dubbo" class="headerlink" title="dubbo"></a>dubbo</h3><ul><li>服务提供者（provider）</li><li>服务消费者（consumer）</li><li>注册中心（registry）</li><li>监控中心（monitor）</li></ul><p>调用关系？？？</p><p>SOA工作原理？？？</p><p>Dubbo与SpringCloud区别？？</p><h3 id="虚拟机安装"><a href="#虚拟机安装" class="headerlink" title="虚拟机安装"></a>虚拟机安装</h3><p> 软件</p><ul><li>jdk1.8</li><li>redis</li><li>dubbo-javaweb</li><li>tomcat 跑 javaweb</li><li>zookeeper</li><li></li></ul><p>分布式架构的服务提供者中Service由dubbo提供，故@Service注解需要换成dubbo的</p><p>服务消费者中Controller的@Autowired注解也只能注入同一容器的服务，无法导入Service，需要使用dubbo的@Reference</p><p>添加dubbo、zookeeper的maven依赖以后运行该项目在zookeeper上面注册服务</p><h1 id="商品管理系统"><a href="#商品管理系统" class="headerlink" title="商品管理系统"></a>商品管理系统</h1><p>sku 与 spu：</p><p>sku：stock keeping util 库存存储单元</p><p>一般具体一个产品    如：amd rx5700xt（拥有具体属性）</p><p>spu：standard product util 标准产品单元</p><p>概念性产品               如：amd rx5700系列显卡</p><p>修改配置，运行前端项目</p><p><strong>跨域问题</strong></p><p>使用@CrossOrigin</p><p>加在控制层里面</p><p>access-control-allow-origin</p><p>主键返回策略？？？？</p><h2 id="增删改查-CURD"><a href="#增删改查-CURD" class="headerlink" title="增删改查(CURD)"></a>增删改查(CURD)</h2><p>平台属性的增删改查</p><p>销售属性的增删改查</p><p>图片列表的增删改查</p><h2 id="分布式文件存储-FastDFS"><a href="#分布式文件存储-FastDFS" class="headerlink" title="分布式文件存储(FastDFS)"></a>分布式文件存储(FastDFS)</h2><p><strong>解决高并发问题<br></strong></p><ol><li>集群？？？？</li><li>多服务器</li><li>限流</li></ol><h1 id="前端页面"><a href="#前端页面" class="headerlink" title="前端页面"></a>前端页面</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><table><thead><tr><th align="center">-</th><th align="center">-</th><th align="center">-</th><th align="center">-</th></tr></thead><tbody><tr><td align="center">前端</td><td align="center">并发大</td><td align="center">负载均衡</td><td align="center">数据一致</td></tr><tr><td align="center">后端</td><td align="center">并发小</td><td align="center">直连数据库</td><td align="center">数据一致</td></tr></tbody></table><h2 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h2><ul><li>首页（静态化）</li><li>检索页（搜索引擎）</li><li>详情页（缓存、切换、推荐）</li><li>购物车页（cookie、redis）</li><li>订单页（结算页）（一致性校验、安全）</li><li>支付页（安全、对接支付平台）</li></ul><h3 id="thymeleaf"><a href="#thymeleaf" class="headerlink" title="thymeleaf"></a>thymeleaf</h3><p>user?.name</p><p>?用来判空，user对象的那么属性为null不报错</p><h3 id="详情页"><a href="#详情页" class="headerlink" title="详情页"></a>详情页</h3><p>根据销售属性确定sku，跳转页面</p><h3 id="页面高并发"><a href="#页面高并发" class="headerlink" title="页面高并发"></a>页面高并发</h3><ol><li>负载均衡，集群（增加服务器数量，增加负载均衡）</li><li>使用缓存</li><li>其他–限流，静态化，分布式</li></ol><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><h4 id="查询步骤"><a href="#查询步骤" class="headerlink" title="查询步骤"></a>查询步骤</h4><ol><li>连接缓存</li><li>查询缓存</li><li>缓存没有结果，查询sql</li><li>sql返回结果给用户并且将结果写入缓存</li></ol><h4 id="整合步骤"><a href="#整合步骤" class="headerlink" title="整合步骤"></a>整合步骤</h4><ol><li><p>将redis整合到项目中（redis+spring）</p><pre><code>1. 将redis框架封装成一个工厂类（将redis的池初始化到spring容器中） 2. 用spring的整合类将工厂类整合</code></pre></li><li><p>设计一个数据存储策略（核心：设计key）</p><p>企业中数据存储策略：</p><p>数据对象名:数据对象ID:对象属性</p><p>user:123:username</p><p>user:123:password</p></li></ol><h4 id="redis常见问题"><a href="#redis常见问题" class="headerlink" title="redis常见问题"></a>redis常见问题</h4><ol><li>can not get a connection from the pool<ul><li>redis不能外网访问 bind 127.0.0.1</li><li>保护模式 protected mode </li></ul></li><li>缓存在高并发以及安全压力下的一些问题<ul><li>缓存击穿（某一热点key在高并发访问情况下突然失效，过期时间到了，导致大量的并发打进sql的情况）—使用redis的分布式锁解决mysql的访问压力问题</li><li>缓存穿透（利用redis和mysql的机制，redis缓存中不存在就访问mysql，直接绕过缓存访问mysql，制造db访问压力）—通过代码防治问题产生，给该一定不存在的key的value设置””或者null</li><li>缓存雪崩（大量缓存设置了相同的过期时间，在某一时刻同时失效，请求全部发到mysql，DB瞬间压力造成雪崩）—-在原定过期时间后加上一个随机时间</li></ul></li></ol><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><ol><li><p>redis自带的分布式锁 set px nx</p><p>上锁—-jedis.set(“xxxlock”,”value_token”,”NX”,”PX”,”10 * 1000”)</p><p>开锁—-jedis.del(“xxxlock”)</p></li><li><p>reidsson 框架 redis jucdelock锁功能  实现（既有jedis的功能，又有juc的功能）jedis没有同步锁</p><p>声明锁—-RLock lock = redissonClient.getLock(“xxxLock”);</p><p>上锁—-lock.lock();</p><p>开锁—-lock.unlock();</p></li></ol><h4 id="nginx负载均衡"><a href="#nginx负载均衡" class="headerlink" title="nginx负载均衡"></a>nginx负载均衡</h4><h4 id="apache压力测试"><a href="#apache压力测试" class="headerlink" title="apache压力测试"></a>apache压力测试</h4><h1 id="elasticsearch-搜索"><a href="#elasticsearch-搜索" class="headerlink" title="elasticsearch 搜索"></a>elasticsearch 搜索</h1><ol><li>ElasticSearch6（与5的区别在于6需要以普通用户登录，6里面一个库只能建立一个表）</li><li>搜索引擎<ol><li>文本搜索（以空间换时间）</li><li>搜索引擎（百度，谷歌）—-爬虫、分析、查询</li></ol></li><li>elasticsearch的算法—-倒排索引（在内容上建立索引，以内容匹配索引）<ul><li>mysql使用Btree –balance tree</li><li>elasticsearch使用B+tree</li></ul></li></ol><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><ul><li>query 查询条件</li><li>from 开始</li><li>size 大小–条数</li><li>highlight 高亮</li><li>aggs 聚合函数</li></ul><h2 id="加入中文分词器"><a href="#加入中文分词器" class="headerlink" title="加入中文分词器"></a>加入中文分词器</h2><p>ik  放在elasticsearch的plugins目录下</p><blockquote><p> GET _analyze<br>{<br>  “analyzer”: “ik_max_word”,<br>  “text”: [“我是中国人”]<br>}</p></blockquote><ul><li>ik_smart</li><li>ik_max_word</li></ul><h2 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h2><p>“:”后面一定要加空格” “，“=”一定不要加空格</p><ol><li>cluster.name</li><li>node.master</li><li>node.data</li><li>path.data</li><li>path.logs</li><li>network.host</li><li>http.port</li><li>transport.tcp.port</li><li>discovery.zen.minimum.master.nodes  最少为node半数+1     —&gt;脑裂？？？</li></ol><p>node.master可以大于1，主节点只能有一个？？？—&gt;脑裂？</p><h2 id="节点、分片、索引"><a href="#节点、分片、索引" class="headerlink" title="节点、分片、索引"></a>节点、分片、索引</h2><ol><li>节点</li></ol><ol start="2"><li>分片</li></ol><ol start="3"><li>索引</li></ol><ol start="4"><li>主分片</li></ol><ol start="5"><li>复制片</li></ol><ol start="6"><li>分片路由<ul><li>Sync</li><li>Async</li></ul></li></ol><h1 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h1><h1 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;项目介绍&quot;&gt;&lt;a href=&quot;#项目介绍&quot; class=&quot;headerlink&quot; title=&quot;项目介绍&quot;&gt;&lt;/a&gt;项目介绍&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h
      
    
    </summary>
    
    
      <category term="项目" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="谷粒" scheme="http://yoursite.com/tags/%E8%B0%B7%E7%B2%92/"/>
    
  </entry>
  
  <entry>
    <title>高数下复习-解题步骤</title>
    <link href="http://yoursite.com/2020/06/07/%E9%AB%98%E6%95%B0%E4%B8%8B%E5%A4%8D%E4%B9%A0-%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4%20/"/>
    <id>http://yoursite.com/2020/06/07/%E9%AB%98%E6%95%B0%E4%B8%8B%E5%A4%8D%E4%B9%A0-%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4%20/</id>
    <published>2020-06-07T14:57:56.000Z</published>
    <updated>2020-06-07T15:16:30.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h1><p>记录一下我苦逼的清考高数。</p><p>高数考试应对</p><h1 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h1><h2 id="两平面的夹角"><a href="#两平面的夹角" class="headerlink" title="两平面的夹角"></a>两平面的夹角</h2><p>a·b=0</p><h2 id="函数在一点处连续性、可偏导性、可微性判断"><a href="#函数在一点处连续性、可偏导性、可微性判断" class="headerlink" title="函数在一点处连续性、可偏导性、可微性判断"></a>函数在一点处连续性、可偏导性、可微性判断</h2><p>偏导连续推出可微。<br>可微推出偏导存在。<br>可微推出连续。<br>以上无法反推。<br>连续和偏导存在，互相不可推。</p><h2 id="第-1-类曲线积分"><a href="#第-1-类曲线积分" class="headerlink" title="第 1 类曲线积分"></a>第 1 类曲线积分</h2><p>ds 等于根号下 1+x 的导数的平方。</p><h2 id="Pdx-加上-qdy-是某函数全微分的条件"><a href="#Pdx-加上-qdy-是某函数全微分的条件" class="headerlink" title="Pdx 加上 qdy 是某函数全微分的条件"></a>Pdx 加上 qdy 是某函数全微分的条件</h2><p>？</p><h2 id="级数连散性条件收敛绝对收敛判断。"><a href="#级数连散性条件收敛绝对收敛判断。" class="headerlink" title="级数连散性条件收敛绝对收敛判断。"></a>级数连散性条件收敛绝对收敛判断。</h2><p>1.判断是否满足收敛的必要条件，若数项级数收敛，则 n 趋向于正无穷时级数的一般项收敛于 0，该必要条件一般用于验证级数发散及一般项不收敛于 0。</p><p>2.正向级数 4 种判别方法。</p><ol><li>比较原则</li><li>比式判别法，含 n！的级数</li><li>根式判别法，用于含 n 次方的技术</li><li>比较判别法的极限形式。</li></ol><p>3.交错级数，用莱布尼茨判别法，判断交错级数是否收敛。</p><p>4.任意项级数，利用绝对收敛的级数一定收敛，判断是否收敛。<br>绝对收敛的级数一定收敛。</p><p>阿贝尔判别法，即迪利克雷判别法判断级数是否收敛，关键在于会拆。<br>阿贝尔判别法，数列 an 单调有界，级数必然收敛推出级数 anbn 收敛，迪利克雷判别法，数列 an 单调且趋于零，级数<br>有界，级数 anbn 收敛。</p><h1 id="填空"><a href="#填空" class="headerlink" title="填空"></a>填空</h1><h2 id="向量的数量积"><a href="#向量的数量积" class="headerlink" title="向量的数量积"></a>向量的数量积</h2><p>注意 k 前面为负号。</p><h2 id="方向导数的计算"><a href="#方向导数的计算" class="headerlink" title="方向导数的计算"></a>方向导数的计算</h2><p>梯度乘以单位向量为方向导数。</p><h2 id="第-1-类曲面积分"><a href="#第-1-类曲面积分" class="headerlink" title="第 1 类曲面积分"></a>第 1 类曲面积分</h2><p>ds=根号下 1+x 一撇的平方，再加上 y 一撇的平方。</p><h2 id="函数的幂级数展开"><a href="#函数的幂级数展开" class="headerlink" title="函数的幂级数展开"></a>函数的幂级数展开</h2><h2 id="傅里叶级数的收敛定理"><a href="#傅里叶级数的收敛定理" class="headerlink" title="傅里叶级数的收敛定理"></a>傅里叶级数的收敛定理</h2><p>?</p><h1 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h1><h2 id="多元函数的极限"><a href="#多元函数的极限" class="headerlink" title="多元函数的极限"></a>多元函数的极限</h2><h2 id="多元函数求偏导二阶"><a href="#多元函数求偏导二阶" class="headerlink" title="多元函数求偏导二阶"></a>多元函数求偏导二阶</h2><h2 id="隐函数求导"><a href="#隐函数求导" class="headerlink" title="隐函数求导"></a>隐函数求导</h2><p>第 1 种方法，两边同时对 x 求导。<br>第 2 种方法，构造大 f 函数为左边方程减右边方程。<br>Dy 比 dx=负的 fx 除以 fy.</p><h2 id="二重积分的计算"><a href="#二重积分的计算" class="headerlink" title="二重积分的计算"></a>二重积分的计算</h2><p>有 x 的平方加 y 的平方，注意换成 p 用极坐标。</p><h2 id="第-2-类曲线积分格林公式"><a href="#第-2-类曲线积分格林公式" class="headerlink" title="第 2 类曲线积分格林公式"></a>第 2 类曲线积分格林公式</h2><p>Q 除以 x，减去 p 除以 y。</p><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="曲线的切线和法平面"><a href="#曲线的切线和法平面" class="headerlink" title="曲线的切线和法平面"></a>曲线的切线和法平面</h2><h2 id="条件极值，拉格朗日乘数法"><a href="#条件极值，拉格朗日乘数法" class="headerlink" title="条件极值，拉格朗日乘数法"></a>条件极值，拉格朗日乘数法</h2><p>构造大 f 等于第 1 个函数减去第 2 个函数。分别求出 fxfyfz，f 那么大。令各项等于 0，求出 xyz。</p><h2 id="曲面围成立体的体积"><a href="#曲面围成立体的体积" class="headerlink" title="曲面围成立体的体积"></a>曲面围成立体的体积</h2><h2 id="第-2-类曲面积分高斯公式。"><a href="#第-2-类曲面积分高斯公式。" class="headerlink" title="第 2 类曲面积分高斯公式。"></a>第 2 类曲面积分高斯公式。</h2><p>P 除以 x 加上，q 除以 y 加上 r 除以 z。</p><h2 id="幂级数的和函数"><a href="#幂级数的和函数" class="headerlink" title="幂级数的和函数"></a>幂级数的和函数</h2><p>先积分后微分或者先微分后积分。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;吐槽&quot;&gt;&lt;a href=&quot;#吐槽&quot; class=&quot;headerlink&quot; title=&quot;吐槽&quot;&gt;&lt;/a&gt;吐槽&lt;/h1&gt;&lt;p&gt;记录一下我苦逼的清考高数。&lt;/p&gt;
&lt;p&gt;高数考试应对&lt;/p&gt;
&lt;h1 id=&quot;选择&quot;&gt;&lt;a href=&quot;#选择&quot; class=&quot;heade
      
    
    </summary>
    
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="清考" scheme="http://yoursite.com/tags/%E6%B8%85%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>笔试</title>
    <link href="http://yoursite.com/2020/06/07/%E7%AC%94%E8%AF%95/"/>
    <id>http://yoursite.com/2020/06/07/%E7%AC%94%E8%AF%95/</id>
    <published>2020-06-07T14:57:54.000Z</published>
    <updated>2020-06-07T15:15:33.326Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>Cookie，Session</p><ol><li>Cookie一般保存在浏览器，不安全；Session一般保存在服务器，Session多了服务器压力大</li><li>Cookie只能存储String类型数据，Session可以保存任意类型数据</li></ol></li><li><p>5常见错误</p><ol><li>命名不规范</li><li>空指针异常未处理</li><li>资源未关闭</li></ol></li><li><p>修改代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList <span class="title">bad_smell_demo</span><span class="params">(String param)</span> </span>&#123; </span><br><span class="line">  ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">  <span class="keyword">if</span> (<span class="string">"xxx"</span>.equals(param)) &#123; </span><br><span class="line">    list.add(param);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">""</span>.equals(param)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        param += <span class="string">"0"</span>; </span><br><span class="line">      &#125; </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> list; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>电脑-浏览器-用户输入百度域名-DNS解析域名获取IP-发送http请求到百度服务器-百度服务器返回百度一下页面-浏览器解析页面并渲染显示页面-用户在输入框输入大米价格并点击百度一下按钮提交表单-百度服务器controller请求对应映射方法进行参数获取并将具体业务交给service处理-service通过类似ElasticSearch的搜索引擎获取大米价格相关结果信息并返回给controller-controller将结果封装成前端页面需要的形式返回-jsp容器使用模版引擎渲染页面显示给用户-用户点击相关页面链接查看具体信息-百度服务器controller接收到要前往的url，重定向到该url-请求获取该url的资源-浏览器渲染页面并显示</p></li><li><p>他趣游玩，两台服务器，一主一从。流量激增可能会遇到服务器处理不过来，网站访问速度变慢，增加服务器，限流。不知道怎么1s查</p></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;Cookie，Session&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Cookie一般保存在浏览器，不安全；Session一般保存在服务器，Session多了服务器压力大&lt;/li&gt;
&lt;li&gt;Cookie只能存储String类型数据，Session可以保存任意类型数据&lt;/
      
    
    </summary>
    
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java中的&lt;&lt; 和 &gt;&gt; 和 &gt;&gt;&gt; 详细分析</title>
    <link href="http://yoursite.com/2020/06/07/%3C%3C,%3E%3E,%3E%3E%3E/"/>
    <id>http://yoursite.com/2020/06/07/%3C%3C,%3E%3E,%3E%3E%3E/</id>
    <published>2020-06-07T14:57:53.000Z</published>
    <updated>2020-06-07T15:15:11.828Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/chuijingjing/p/9405598.html" target="_blank" rel="noopener">Java中的&lt;&lt; 和 &gt;&gt; 和 &gt;&gt;&gt; 详细分析</a></p><p><strong>&lt;&lt;表示左移移，不分正负数，低位补0；</strong>　</p><p>注：以下数据类型默认为byte-8位</p><p>左移时不管正负，低位补0</p><p>正数：<strong>r = 20 &lt;&lt; 2</strong></p><p>　　20的二进制补码：<strong>0001 0100</strong></p><p>　　向左移动两位后：<strong>0101 0000</strong></p><p>　　　　  　　结果：<strong>r = 80</strong></p><p>负数：<strong>r = -20 &lt;&lt; 2</strong></p><p>　　-20 的二进制原码 ：<strong>1001 0100</strong></p><p>　　-20 的二进制反码 <strong><em>\</em>：\</strong>1110 1011**</p><p>　　-20 的二进制补码 ：<strong>1110 1100</strong></p><p>　　左移两位后的补码：<strong>1011 0000</strong></p><p>　　　　　　　　反码：*<em>1010 1111<br>*</em></p><p>　　　　　　　　原码：*<em>1101 0000<br>*</em></p><p>　　　　　　　　结果：*<em>r = -80<br>*</em></p><p><strong>&gt;&gt;表示右移，如果该数为正，则高位补0，若为负数，则高位补1；</strong></p><p>注：以下数据类型默认为byte-8位</p><p>正数：<strong>r = 20 &gt;&gt; 2</strong></p><p>　　20的二进制补码：<strong>0001 0100</strong></p><p>　　向右移动两位后：<strong>0000 0101</strong></p><p>　　　　　　　结果：<strong>r = 5</strong></p><p>负数：<strong>r = -20 &gt;&gt; 2</strong></p><p>　　-20 的二进制原码 ：<strong>1001 0100</strong></p><p>　　-20 的二进制反码 *<em>：1110 1011<br>*</em></p><p>　　-20 的二进制补码 ：<strong>1110 1100</strong> </p><p>　　右移两位后的补码：<strong>1111 1011</strong> </p><p>　　　　　　　　反码：<strong>1111 1010</strong></p><p>　　　　　　　　原码：<strong>1000 0101</strong></p><p>　　　　　　　　结果：<strong>r = -5</strong></p><p><strong>&gt;&gt;&gt;表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0</strong></p><p>正数：　<strong>r = 20 &gt;&gt;&gt; 2</strong></p><p>　　　　的结果与 r = 20 &gt;&gt; 2 相同；</p><p>负数：　<strong>r = -20 &gt;&gt;&gt; 2</strong></p><p>注：以下数据类型默认为int 32位</p><p>　　-20:源码：<strong>10000000 00000000 00000000 00010100</strong></p><p>　　　　反码：<strong>11111111 11111111  11111111  11101011</strong></p><p>　　　　补码：<strong>11111111 11111111  11111111  11101100</strong></p><p>　　　　右移：<strong>00111111 11111111  11111111  11111011</strong></p><p>　　　　结果：<strong>r = 1073741819</strong></p><p>借鉴来的，总结一下就是对于正数来说，直接左移，右移，负数的 &gt;&gt; ➕1，&lt;&lt;➕0，&gt;&gt;&gt;都➕0</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/chuijingjing/p/9405598.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java中的&amp;lt;&amp;lt; 和 &amp;gt;&amp;gt; 和 &amp;gt;&amp;gt;&amp;gt; 详细分
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>啊哈！算法</title>
    <link href="http://yoursite.com/2020/06/07/%E5%95%8A%E5%93%88%EF%BC%81%E7%AE%97%E6%B3%95%20/"/>
    <id>http://yoursite.com/2020/06/07/%E5%95%8A%E5%93%88%EF%BC%81%E7%AE%97%E6%B3%95%20/</id>
    <published>2020-06-07T14:57:53.000Z</published>
    <updated>2020-06-07T15:15:27.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我基础太差了。就从最简单，能看下去的这本书开始吧</p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>Code：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> a[<span class="number">11</span>],i,j,t;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">a[i]=<span class="number">0</span>; <span class="comment">//初始化为0</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) <span class="comment">//循环读入5个数 &#123;</span></span><br><span class="line">  scanf(<span class="string">"%d"</span>,&amp;t); <span class="comment">//把每一个数读到变量t中</span></span><br><span class="line">  a[t]++; <span class="comment">//进行计数 &#125;</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++) <span class="comment">//依次判断a[0]~a[10]</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;  j&lt;=a[i];j++) <span class="comment">//出现了几次就打印几次</span></span><br><span class="line">      printf(<span class="string">"%d "</span>,i);</span><br><span class="line">      getchar();getchar(); <span class="comment">//这里的getchar();用来暂停程序，以便查看程序输出的内容 //也可以用system("pause");等来代替</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><blockquote><p>冒泡排序的基本思想是:每次比较两个相邻的元素，如果它们的顺序错误就把它们交换 过来。</p></blockquote><p>Code:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> a[<span class="number">100</span>],i,j,t,n;</span><br><span class="line">scanf(<span class="string">"%d"</span>,&amp;n); <span class="comment">//输入一个数n，表示接下来有n个数 for(i=1;i&lt;=n;i++) //循环读入n个数到数组a中</span></span><br><span class="line">        scanf(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        <span class="comment">//冒泡排序的核心部分</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++) <span class="comment">//n个数排序，只用进行n-1趟 &#123;</span></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n-i;j++) <span class="comment">//从第1位开始比较直到最后一个尚未归位的数，想一想为什 么到n-i就可以了。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j]&lt;a[j+<span class="number">1</span>]) <span class="comment">//比较大小并交换</span></span><br><span class="line">&#123; t=a[j]; a[j]=a[j+<span class="number">1</span>]; a[j+<span class="number">1</span>]=t; &#125;</span><br><span class="line">&#125; &#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) <span class="comment">//输出结果 printf("%d ",a[i]);</span></span><br><span class="line">        getchar();getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><p>pic</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>Code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">101</span>],n;<span class="comment">//定义全局变量，这两个变量需要在子函数中使用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,t,temp;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">temp=a[left]; <span class="comment">//temp中存的就是基准数 i=left;</span></span><br><span class="line">j=right;</span><br><span class="line"><span class="keyword">while</span>(i!=j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//顺序很重要，要先从右往左找 while(a[j]&gt;=temp &amp;&amp; i&lt;j)</span></span><br><span class="line">j--; <span class="comment">//再从左往右找</span></span><br><span class="line">        <span class="keyword">while</span>(a[i]&lt;=temp &amp;&amp; i&lt;j)</span><br><span class="line">            i++;</span><br><span class="line"><span class="comment">//交换两个数在数组中的位置 if(i&lt;j)//当哨兵i和哨兵j没有相遇时 &#123;</span></span><br><span class="line">            t=a[i];</span><br><span class="line">            a[i]=a[j];</span><br><span class="line">            a[j]=t;</span><br><span class="line">&#125; &#125;</span><br><span class="line"><span class="comment">//最终将基准数归位</span></span><br><span class="line">a[left]=a[i];</span><br><span class="line">    a[i]=temp;</span><br><span class="line">quicksort(left,i<span class="number">-1</span>);<span class="comment">//继续处理左边的，这里是一个递归的过程</span></span><br><span class="line">quicksort(i+<span class="number">1</span>,right);<span class="comment">//继续处理右边的，这里是一个递归的过程 &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,t; <span class="comment">//读入数据 scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]); quicksort(<span class="number">1</span>,n); <span class="comment">//快速排序调用</span></span><br><span class="line"><span class="comment">//输出排序后的结果 for(i=1;i&lt;=n;i++)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">    getchar();getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><p>pic</p><p><strong><em>我们来回顾一下本章三种排序算法的时间复杂度。桶排序是最快的，它的时间复杂度是 O(N+M);冒泡排序是 O(N 2);快速排序是 O(NlogN)。\</em></strong></p><h1 id="栈、队列、链表"><a href="#栈、队列、链表" class="headerlink" title="栈、队列、链表"></a>栈、队列、链表</h1><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><blockquote><p>“先进先出”(First In First Out，FIFO)原则。</p></blockquote><p>队列将是我们今后学习广度优先搜索以及队列优化的 Bellman-Ford 最短路算法的核心 数据结构。所以现在将队列的三个基本元素(一个数组，两个变量)封装为一个结构体类型， 如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data[<span class="number">100</span>];<span class="comment">//队列的主体，用来存储内容 int head;//队首</span></span><br><span class="line"><span class="keyword">int</span> tail;<span class="comment">//队尾 &#125;;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queue</span> <span class="title">q</span>;</span> <span class="keyword">int</span> i; <span class="comment">//初始化队列 q.head=1; q.tail=1; for(i=1;i&lt;=9;i++) &#123;</span></span><br><span class="line"><span class="comment">//依次向队列插入9个数 scanf("%d",&amp;q.data[q.tail]); q.tail++;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(q.head&lt;q.tail) <span class="comment">//当队列不为空的时候执行循环 &#123;</span></span><br><span class="line"><span class="comment">//打印队首并将队首出队 printf("%d ",q.data[q.head]); q.head++;</span></span><br><span class="line"><span class="comment">//先将新队首的数添加到队尾 q.data[q.tail]=q.data[q.head]; q.tail++;</span></span><br><span class="line"><span class="comment">//再将队首出队</span></span><br><span class="line">q.head++; &#125;</span><br><span class="line">    getchar();getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>入栈的操作 是 top++;s[top]=x(;假设需要入栈的字符暂存在字符变量 x 中)，其实可以简写为 s[++top]=x;</p><p>判断回文：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">101</span>],s[<span class="number">101</span>];</span><br><span class="line">    <span class="keyword">int</span> i,len,mid,next,top;</span><br><span class="line">gets(a); <span class="comment">//读入一行字符串 len=strlen(a); //求字符串的长度 mid=len/2-1; //求字符串的中点</span></span><br><span class="line">top=<span class="number">0</span>;<span class="comment">//栈的初始化 //将mid前的字符依次入栈 for(i=0;i&lt;=mid;i++)</span></span><br><span class="line">        s[++top]=a[i];</span><br><span class="line"><span class="comment">//判断字符串的长度是奇数还是偶数，并找出需要进行字符匹配的起始下标 if(len%2==0)</span></span><br><span class="line">        next=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">next=mid+<span class="number">2</span>;</span><br><span class="line"><span class="comment">//开始匹配 for(i=next;i&lt;=len-1;i++)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=s[top])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果top的值为0，则说明栈内所有的字符都被一一匹配了 if(top==0)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"YES"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NO"</span>);</span><br><span class="line">    getchar();getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><h2 id="小猫钓鱼"><a href="#小猫钓鱼" class="headerlink" title="小猫钓鱼"></a>小猫钓鱼</h2><p>Code:</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#<span class="meta-keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line">struct queue</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="title">data</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">head</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">tail</span>;</span><br><span class="line">&#125;;</span><br><span class="line">struct stack</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="title">data</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> top; &#125;;</span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">    struct queue q1,q2;</span><br><span class="line">    struct stack s;</span><br><span class="line">    <span class="keyword">int</span> book[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> i,t;</span><br><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line">q1.<span class="built_in">head</span>=<span class="number">1</span>; q1.<span class="built_in">tail</span>=<span class="number">1</span>;</span><br><span class="line">q2.<span class="built_in">head</span>=<span class="number">1</span>; q2.<span class="built_in">tail</span>=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line">s.top=<span class="number">0</span>; <span class="comment">//初始化用来标记的数组，用来标记哪些牌已经在桌上 for(i=1;i&lt;=9;i++)</span></span><br><span class="line">book[i]=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//依次向队列插入6个数 //小哼手上的6张牌 for(i=1;i&lt;=6;i++) &#123;</span></span><br><span class="line">        scanf(<span class="string">"%d"</span>,&amp;q1.<span class="title">data</span>[q1.<span class="built_in">tail</span>]);</span><br><span class="line">q1.<span class="built_in">tail</span>++; &#125;</span><br><span class="line"><span class="comment">//小哈手上的6张牌 for(i=1;i&lt;=6;i++) &#123;</span></span><br><span class="line">        scanf(<span class="string">"%d"</span>,&amp;q2.<span class="title">data</span>[q2.<span class="built_in">tail</span>]);</span><br><span class="line">q2.<span class="built_in">tail</span>++; &#125;</span><br><span class="line"><span class="keyword">while</span>(q1.<span class="built_in">head</span>&lt;q1.<span class="built_in">tail</span> &amp;&amp; q2.<span class="built_in">head</span>&lt;q2.<span class="built_in">tail</span> ) <span class="comment">//当队列不为空的时候执行循环 &#123;</span></span><br><span class="line">t=q1.<span class="title">data</span>[q1.<span class="built_in">head</span>];<span class="comment">//小哼出一张牌 //判断小哼当前打出的牌是否能赢牌 if(book[t]==0) //表明桌上没有牌面为t的牌</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//小哼此轮没有赢牌</span></span><br><span class="line">q1.<span class="built_in">head</span>++; <span class="comment">//小哼已经打出一张牌，所以要把打出的牌出队 s.top++;</span></span><br><span class="line">s.<span class="title">data</span>[s.top]=t; <span class="comment">//再把打出的牌放到桌上，即入栈 book[t]=1; //标记桌上现在已经有牌面为t的牌</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//小哼此轮可以赢牌 q1.head++;//小哼已经打出一张牌，所以要把打出的牌出队 q1.data[q1.tail]=t;//紧接着把打出的牌放到手中牌的末尾 q1.tail++;</span></span><br><span class="line"><span class="keyword">while</span>(s.<span class="title">data</span>[s.top]!=t) <span class="comment">//把桌上可以赢得的牌依次放到手中牌的末尾 &#123;</span></span><br><span class="line">book[s.<span class="title">data</span>[s.top]]=<span class="number">0</span>;<span class="comment">//取消标记 q1.data[q1.tail]=s.data[s.top];//依次放入队尾 q1.tail++;</span></span><br><span class="line">s.top--; <span class="comment">//栈中少了一张牌，所以栈顶要减1</span></span><br><span class="line">&#125; &#125;</span><br><span class="line">t=q2.<span class="title">data</span>[q2.<span class="built_in">head</span>]; <span class="comment">//小哈出一张牌 //判断小哈当前打出的牌是否能赢牌 if(book[t]==0) //表明桌上没有牌面为t的牌 &#123;</span></span><br><span class="line"><span class="comment">//小哈此轮没有赢牌</span></span><br><span class="line">q2.<span class="built_in">head</span>++; <span class="comment">//小哈已经打出一张牌，所以要把打出的牌出队 s.top++;</span></span><br><span class="line">s.<span class="title">data</span>[s.top]=t; <span class="comment">//再把打出的牌放到桌上，即入栈 book[t]=1; //标记桌上现在已经有牌面为t的牌</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//小哈此轮可以赢牌 q2.head++;//小哈已经打出一张牌，所以要把打出的牌出队 q2.data[q2.tail]=t;//紧接着把打出的牌放到手中牌的末尾 q2.tail++;</span></span><br><span class="line"><span class="keyword">while</span>(s.<span class="title">data</span>[s.top]!=t) <span class="comment">//把桌上可以赢得的牌依次放到手中牌的末尾 &#123;</span></span><br><span class="line">book[s.<span class="title">data</span>[s.top]]=<span class="number">0</span>;<span class="comment">//取消标记</span></span><br><span class="line">q2.<span class="title">data</span>[q2.<span class="built_in">tail</span>]=s.<span class="title">data</span>[s.top];<span class="comment">//依次放入队尾 q2.tail++;</span></span><br><span class="line">s.top--;</span><br><span class="line">&#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(q2.<span class="built_in">head</span>==q2.<span class="built_in">tail</span>)</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"小哼win\n"</span>); printf(<span class="string">"小哼当前手中的牌是"</span>); <span class="keyword">for</span>(i=q1.<span class="built_in">head</span>;i&lt;=q1.<span class="built_in">tail</span>-<span class="number">1</span>;i++)</span><br><span class="line">printf(<span class="string">" %d"</span>,q1.<span class="title">data</span>[i]); <span class="keyword">if</span>(s.top&gt;<span class="number">0</span>) <span class="comment">//如果桌上有牌则依次输出桌上的牌 &#123;</span></span><br><span class="line">printf(<span class="string">"\n桌上的牌是"</span>); <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=s.top;i++)</span><br><span class="line">printf(<span class="string">" %d"</span>,s.<span class="title">data</span>[i]); printf(<span class="string">"\n桌上已经没有牌了"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">printf(<span class="string">"小哈win\n"</span>); printf(<span class="string">"小哈当前手中的牌是"</span>); <span class="keyword">for</span>(i=q2.<span class="built_in">head</span>;i&lt;=q2.<span class="built_in">tail</span>-<span class="number">1</span>;i++)</span><br><span class="line">printf(<span class="string">" %d"</span>,q2.<span class="title">data</span>[i]); <span class="keyword">if</span>(s.top&gt;<span class="number">0</span>) <span class="comment">//如果桌上有牌则依次输出桌上的牌 &#123;</span></span><br><span class="line">printf(<span class="string">"\n桌上的牌是"</span>); <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=s.top;i++)</span><br><span class="line">printf(<span class="string">" %d"</span>,s.<span class="title">data</span>[i]); printf(<span class="string">"\n桌上已经没有牌了"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">&#125;</span><br><span class="line">    getchar();getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>Code：下面来设置头指针并设置新创建结点的*next 指向空</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; //这里创建一个结构体用来表示链表的结点类型 struct node</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">head</span>,*<span class="title">p</span>,*<span class="title">q</span>,*<span class="title">t</span>;</span> <span class="keyword">int</span> i,n,a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">head = <span class="literal">NULL</span>;<span class="comment">//头指针初始为空 for(i=1;i&lt;=n;i++)//循环读入n个数 &#123;</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a); <span class="comment">//动态申请一个空间，用来存放一个结点，并用临时指针p指向这个结点</span></span><br><span class="line">p=(struct node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct node)); p-&gt;data=a;<span class="comment">//将数据存储到当前结点的data域中 p-&gt;next=NULL;//设置当前结点的后继指针指向空，也就是当前结点的下一个结点为空 if(head==NULL)</span></span><br><span class="line">head=p;<span class="comment">//如果这是第一个创建的结点，则将头指针指向这个结点 else</span></span><br><span class="line">q-&gt;next=p;<span class="comment">//如果不是第一个创建的结点，则将上一个结点的后继指针指向当前结点 q=p;//指针q也指向当前结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出链表中的所有数 t=head; while(t!=NULL)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,t-&gt;data);</span><br><span class="line">t=t-&gt;next;<span class="comment">//继续下一个结点 &#125;</span></span><br><span class="line">    getchar();getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><p>Code:插入</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"><span class="comment">//这里创建一个结构体用来表示链表的结点类型 struct node</span></span><br><span class="line">&#123;</span><br><span class="line">int <span class="keyword">data</span>;</span><br><span class="line">struct node *next;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">struct node *head,*p,*q,_t; int i,n,a;</span><br><span class="line">scanf(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">head = NULL;<span class="comment">//头指针初始为空 for(i=1;i&lt;=n;i++)//循环读入 n 个数 &#123;</span></span><br><span class="line">scanf(<span class="string">"%d"</span>,&amp;a); <span class="comment">//动态申请一个空间，用来存放一个结点，并用临时指针 p 指向这个结点</span></span><br><span class="line"><span class="function"><span class="title">p</span>=(struct node _)malloc(sizeof(struct node)); p-&gt;</span><span class="function"><span class="title">data</span>=a;//将数据存储到当前结点的 <span class="keyword">data</span> 域中 p-&gt;</span>next=NULL;<span class="comment">//设置当前结点的后继指针指向空，也就是当前结点的下一个结点为空 if(head==NULL)</span></span><br><span class="line">head=p;<span class="comment">//如果这是第一个创建的结点，则将头指针指向这个结点 else</span></span><br><span class="line"><span class="function"><span class="title">q</span>-&gt;</span>next=p;<span class="comment">//如果不是第一个创建的结点，则将上一个结点的后继指针指向当前结点</span></span><br><span class="line">q=p;<span class="comment">//指针 q 也指向当前结点</span></span><br><span class="line">&#125;</span><br><span class="line">scanf(<span class="string">"%d"</span>,&amp;a);<span class="comment">//读入待插入的数 t=head;//从链表头部开始遍历 while(t!=NULL)//当没有到达链表尾部的时候循环 &#123;</span></span><br><span class="line"><span class="function"><span class="title">if</span>(t-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span><span class="keyword">data</span> &gt; a)<span class="comment">//如果当前结点下一个结点的值大于待插入数，将数插入到中间 &#123;</span></span><br><span class="line">用来存放新增结点</span><br><span class="line">p=(struct node \*)malloc(sizeof(struct node));<span class="comment">//动态申请一个空间，</span></span><br><span class="line"><span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">data</span>=a; p-&gt;</span><span class="function"><span class="title">next</span>=t-&gt;</span>next;<span class="comment">//新增结点的后继指针指向当前结点的后继指针所指向的结点</span></span><br><span class="line"><span class="function"><span class="title">t</span>-&gt;</span>next=p;<span class="comment">//当前结点的后继指针指向新增结点</span></span><br><span class="line">break;<span class="comment">//插入完毕退出循环 &#125;</span></span><br><span class="line"><span class="function"><span class="title">t</span>=t-&gt;</span>next;<span class="comment">//继续下一个结点 &#125;</span></span><br><span class="line"><span class="comment">//输出链表中的所有数 t=head; while(t!=NULL)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="title">printf</span>("%d ",t-&gt;</span><span class="keyword">data</span>);</span><br><span class="line"><span class="function"><span class="title">t</span>=t-&gt;</span>next;<span class="comment">//继续下一个结点 &#125;</span></span><br><span class="line">getchar();getchar();</span><br><span class="line">return <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><h2 id="模拟链表"><a href="#模拟链表" class="headerlink" title="模拟链表"></a>模拟链表</h2><p>Code：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> data[<span class="number">101</span>],<span class="built_in">right</span>[<span class="number">101</span>];</span><br><span class="line"><span class="built_in">int</span> i,<span class="built_in">n</span>,<span class="built_in">t</span>,<span class="built_in">len</span>; //读入已有的数 scanf(<span class="string">"%d"</span>,&amp;<span class="built_in">n</span>); for(i=<span class="number">1</span>;i&lt;=<span class="built_in">n</span>;i++)</span><br><span class="line">    scanf(<span class="string">"%d"</span>,&amp;data[i]);</span><br><span class="line"><span class="built_in">len</span>=<span class="built_in">n</span>;</span><br><span class="line">//初始化数组<span class="built_in">right</span> for(i=<span class="number">1</span>;i&lt;=<span class="built_in">n</span>;i++) &#123;</span><br><span class="line">    <span class="built_in">if</span>(i!=<span class="built_in">n</span>)</span><br><span class="line">        <span class="built_in">right</span>[i]=i+<span class="number">1</span>;</span><br><span class="line">    else</span><br><span class="line">        <span class="built_in">right</span>[i]=<span class="number">0</span>;</span><br><span class="line">&#125; //直接在数组data的末尾增加一个数 <span class="built_in">len</span>++; scanf(<span class="string">"%d"</span>,&amp;data[<span class="built_in">len</span>]);</span><br><span class="line">//从链表的头部开始遍历 <span class="built_in">t</span>=<span class="number">1</span>;</span><br><span class="line">while(<span class="built_in">t</span>!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">if</span>(data[<span class="built_in">right</span>[<span class="built_in">t</span>]]&gt;data[<span class="built_in">len</span>])//如果当前结点下一个结点的值大于待插入数，将 &#123;</span><br><span class="line"><span class="built_in">right</span>[<span class="built_in">len</span>]=<span class="built_in">right</span>[<span class="built_in">t</span>];//新插入数的下一个结点标号等于当前结点的下一个结</span><br><span class="line"><span class="built_in">right</span>[<span class="built_in">t</span>]=<span class="built_in">len</span>;//当前结点的下一个结点编号就是新插入数的编号</span><br><span class="line">break;//插入完成跳出循环 &#125;</span><br><span class="line">    <span class="built_in">t</span>=<span class="built_in">right</span>[<span class="built_in">t</span>];</span><br><span class="line">&#125;</span><br><span class="line">//输出链表中所有的数 <span class="built_in">t</span>=<span class="number">1</span>;</span><br><span class="line">while(<span class="built_in">t</span>!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">"%d "</span>,data[<span class="built_in">t</span>]);</span><br><span class="line">    <span class="built_in">t</span>=<span class="built_in">right</span>[<span class="built_in">t</span>];</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line">    getchar();</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><h2 id="计算-xxx-xxx-xxx，x-1-9-："><a href="#计算-xxx-xxx-xxx，x-1-9-：" class="headerlink" title="计算 xxx+xxx=xxx，x=[1-9]："></a>计算 xxx+xxx=xxx，x=[1-9]：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="炸弹人"><a href="#炸弹人" class="headerlink" title="炸弹人"></a>炸弹人</h2><h2 id="火柴棍等式"><a href="#火柴棍等式" class="headerlink" title="火柴棍等式"></a>火柴棍等式</h2><h2 id="数的全排列"><a href="#数的全排列" class="headerlink" title="数的全排列"></a>数的全排列</h2><h1 id="万能的搜索"><a href="#万能的搜索" class="headerlink" title="万能的搜索"></a>万能的搜索</h1><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p>Code：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> <span class="built_in">step</span>)</span></span>&#123;</span><br><span class="line">  判断边界</span><br><span class="line">  尝试每一种可能<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++&gt;)&#123;</span><br><span class="line">    继续下一步dfs(<span class="built_in">step</span>+<span class="number">1</span>])</span><br><span class="line">  &#125;</span><br><span class="line">  返回</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迷宫"><a href="#迷宫" class="headerlink" title="迷宫"></a>迷宫</h2><h2 id="广度优先排序"><a href="#广度优先排序" class="headerlink" title="广度优先排序"></a>广度优先排序</h2><p>层层递进</p><p>用队列存储已经走过的点</p><h2 id="解决炸弹人问题"><a href="#解决炸弹人问题" class="headerlink" title="解决炸弹人问题"></a>解决炸弹人问题</h2><p>炸弹人会出现在无法到达的地点以至于结果错误。<br>利用广度优先枚举出炸弹人可以到达的地方<br>也可以使用深度优先</p><h2 id="宝岛探险"><a href="#宝岛探险" class="headerlink" title="宝岛探险"></a>宝岛探险</h2><p>Floodfill 漫水填充法</p><h2 id="水管工游戏"><a href="#水管工游戏" class="headerlink" title="水管工游戏"></a>水管工游戏</h2><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p>时间戳：顶点被访问的顺序</p><h2 id="深度与广度优先究竟是啥"><a href="#深度与广度优先究竟是啥" class="headerlink" title="深度与广度优先究竟是啥"></a>深度与广度优先究竟是啥</h2><p>深度遍历主要思想：<br>以一个未被访问过的顶点作为起始顶点，<br>沿当前顶点的边走到未被访问过的顶点，<br>当没有未被访问过的顶点时，则返回上一个顶点，<br>继续试探访问别的顶点，直到所有顶点都被访问过。</p><p>广度遍历主要思想：<br>以一个未被访问过的顶点作为起始顶点，<br>访问其所有相邻的顶点，然后对每个相邻的顶点，<br>再访问他们相邻的所有未被访问过的顶点，直到所有顶点都被访问</p><h2 id="城市地图-图的优先遍历"><a href="#城市地图-图的优先遍历" class="headerlink" title="城市地图-图的优先遍历"></a>城市地图-图的优先遍历</h2><p>存图方法</p><ul><li>图的邻接矩阵表示法 – 二维数组</li><li>邻接表</li></ul><h2 id="最少转机-图的广度优先遍历"><a href="#最少转机-图的广度优先遍历" class="headerlink" title="最少转机-图的广度优先遍历"></a>最少转机-图的广度优先遍历</h2><p>队列</p><h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><h2 id="只有五行的算法-Floyd-Warshall"><a href="#只有五行的算法-Floyd-Warshall" class="headerlink" title="只有五行的算法-Floyd-Warshall"></a>只有五行的算法-Floyd-Warshall</h2><p>不能解决‘负权回路’的图</p><h2 id="Dijksstr-算法-通过边实现松弛"><a href="#Dijksstr-算法-通过边实现松弛" class="headerlink" title="Dijksstr 算法-通过边实现松弛"></a>Dijksstr 算法-通过边实现松弛</h2><p>单源最短路径</p><p>基本思想：<br>每次找到离源点最近的一个顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有顶点的最短路径</p><p>边数 M &lt; 顶点数 N^2 –&gt;稀疏图 –&gt;可用邻接表<br>边数 M &gt; 顶点数 N^2 –&gt;稠密图</p><h2 id="Bellman-Ford-解决负权边"><a href="#Bellman-Ford-解决负权边" class="headerlink" title="Bellman-Ford 解决负权边"></a>Bellman-Ford 解决负权边</h2><h2 id="Bellman-Ford-队列优化"><a href="#Bellman-Ford-队列优化" class="headerlink" title="Bellman-Ford 队列优化"></a>Bellman-Ford 队列优化</h2><p>在每实施一次松弛操作后，就会有一些顶点已经求得其最短路径，但每次还要判断是否需要松弛，浪费了时间。</p><p>==</p><p>每次仅对最短路估计值发生变化了的顶点的所有出边执行松弛操作。</p><p>使用队列优化的 bellman Ford 算法的关键之处在于，只有那些在<strong><em>前一遍松弛中改变了最短路程估计值的顶点\</em></strong>才可能引起他们连接点最短路程估计值发生改变。</p><h1 id="神奇的树"><a href="#神奇的树" class="headerlink" title="神奇的树"></a>神奇的树</h1><h2 id="开启树之旅"><a href="#开启树之旅" class="headerlink" title="开启树之旅"></a>开启树之旅</h2><p>树其实是不包含回路的连通无向图。指任意两个节点中有且只有一条路径的无向图。</p><p>特性：</p><ol><li>一棵树中的任意两个结点有且仅有唯一的一条路径连通</li><li>一棵树如果有 n 个节点，那么它一定恰好有 n-1 条边。</li><li>在一棵树中加一条边将会构成一个回路。</li></ol><p>根又叫根结点，一棵树有且只有一个根结点。根结点有时候也称为祖先。如果一个节点没有子节点，那么这个节点称为叶节点。没有父节点的节点称为根节点。如果一个节点既不是根节点，也不是叶节点，则称为内部节点。<strong>深度</strong>是指从根到这个节点的层数（根为第 1 层）。</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是一种特殊的树，二叉树的特点是每个节点最多有两个儿子，左边的叫左儿子，右边的叫右儿子，或者说每个节点最多有两颗子树，更加严格的递归定义是二叉树要么为空，要么由根节点，左子树和右子树组成，而左子树和右子树分别是一棵二叉树。</p><p>二叉树中还有两种特殊的二叉树，叫做满二叉树和完全二叉树。</p><ul><li><p>如果二叉树中每个内部节点都有两个儿子，这样的二叉树叫做满二叉树。满二叉树，所有的叶节点都有同样的深度。</p><p>满二叉树的严格的定义是一颗深度为 h 且有 2 的 h 次方减一个节点的二叉树。</p></li><li><p>如果一棵二叉树除了最右边位置上有一个或几个叶节点缺少外，其他是丰满的，那么这样的二叉树就是完全二叉树。</p><p>严格的定义是，若设二叉树的高度为 h，除除 h 层外其他各层的节点数都达到最大个数，第 h 层从右往左连续缺若干个节点。则这个二叉树就是完全二叉树。</p></li></ul><p>如果完全二叉树的一个父节点编号为 k，那么他做儿子的编号就是 2k，右儿子的编号就是 2k+1。<br>如果已知儿子（左儿子或右儿子）的编号是 x，那么它父节点的编号就是 x/2。<br>如果一颗完全二叉树有 n 个节点，那么这个完全凹凸处的高度为 log2 n，简写为 log n。即最多有 logo n 层节点。</p><p>完全二叉树的最典型应用就是堆。</p><h2 id="堆-神奇的优先队列"><a href="#堆-神奇的优先队列" class="headerlink" title="堆-神奇的优先队列"></a>堆-神奇的优先队列</h2><p>堆是一种特殊的完全二叉树，如果所有父节点都比子节点小，我们称为最小堆，如果所有父节点都比子节点大，这样的完全二叉树称为最大堆。</p><h2 id="擒贼先擒王-并查集"><a href="#擒贼先擒王-并查集" class="headerlink" title="擒贼先擒王-并查集"></a>擒贼先擒王-并查集</h2><p>并查集也称为不相交集数据结构。</p><h1 id="更多精彩算法"><a href="#更多精彩算法" class="headerlink" title="更多精彩算法"></a>更多精彩算法</h1><h2 id="镖局运镖-图的最小生成树"><a href="#镖局运镖-图的最小生成树" class="headerlink" title="镖局运镖-图的最小生成树"></a>镖局运镖-图的最小生成树</h2><p>要想让有 n 个顶点的图联通，那么至少需要 n-1 条边。</p><p>先选择最短的边，然后选择次短的边，直到选择了 n-1 条边为止。</p><h2 id="再谈最小生成树"><a href="#再谈最小生成树" class="headerlink" title="再谈最小生成树"></a>再谈最小生成树</h2><p>将图中所有的顶点分为两类树顶点（已被选入生成树的顶点）和非速顶点（还未被选入生成树的顶点），首先选择任意一个顶点加入生成树，你可以理解为生成树的根，接下来要找出一条边添加到生成树，这需要枚举每一个树顶点到每一个非树顶点所有的边，然后找到最短边加入到生成树，照此方法重复操作 n-1 次，直到将所有的顶点都加入生成树中。</p><h2 id="重要城市-图的割点"><a href="#重要城市-图的割点" class="headerlink" title="重要城市-图的割点"></a>重要城市-图的割点</h2><p>在一个无向连通图中，如果删除某个顶点后图不再连通（即任意 2 点之间不能相互到达），我们称这样的顶点为割点/割顶</p><h2 id="关键道路-图的割边"><a href="#关键道路-图的割边" class="headerlink" title="关键道路-图的割边"></a>关键道路-图的割边</h2><p>割边也成为桥，即在一个无向连通图中，如果删除某条边后图不再连通。</p><h2 id="二分图最大匹配"><a href="#二分图最大匹配" class="headerlink" title="二分图最大匹配"></a>二分图最大匹配</h2><p>二分图的定义：如果一个图的所有顶点可以被分为 x 和 y 两个集合，并且所有边的两个顶点恰好一个属于集合 x，另一个属于集合 y，即每个集合内的顶点没有边相连，那么此图就是二分图。</p><p>判断一个图是否为二分图也非常简单，首先将任意一个顶点着红色，然后将其相邻的顶点着蓝色，如果按照这样的着色方法，可以将全部顶点着色的话，并且相邻的顶点着色不同，那么该图就是二分图。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我基础太差了。就从最简单，能看下去的这本书开始吧&lt;/p&gt;
&lt;h1 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="进阶" scheme="http://yoursite.com/categories/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2020-05-11   graduation问题</title>
    <link href="http://yoursite.com/2020/06/07/elasticsearch%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/06/07/elasticsearch%E4%BD%BF%E7%94%A8/</id>
    <published>2020-06-07T14:57:52.000Z</published>
    <updated>2020-06-07T15:07:51.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>跳过</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><ul><li>index：类似mysql的database</li><li>type：类似mysql的table</li><li>document：类似mysql一条数据</li><li>filed：类似mysql属性</li></ul><h1 id="插数据"><a href="#插数据" class="headerlink" title="插数据"></a>插数据</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">PUT gmallpms</span><br><span class="line">&#123;</span><br><span class="line"> "mappings": &#123;</span><br><span class="line">   "PmsSkuInfo":&#123;</span><br><span class="line">     "properties": &#123;</span><br><span class="line">       "id":&#123;</span><br><span class="line">        "type": "keyword",</span><br><span class="line">        "index": true</span><br><span class="line">      &#125;,</span><br><span class="line">      "skuName":&#123;</span><br><span class="line">        "type": "text",</span><br><span class="line">        "analyzer": "ik_max_word"</span><br><span class="line">      &#125;,</span><br><span class="line">      "skuDesc":&#123;</span><br><span class="line">        "type": "text"</span><br><span class="line">        , "analyzer": "ik_smart"</span><br><span class="line">      &#125;,</span><br><span class="line">      "catalog3Id":&#123;</span><br><span class="line">        "type": "keyword"</span><br><span class="line">      &#125;,</span><br><span class="line">      "price":&#123;</span><br><span class="line">        "type": "double"</span><br><span class="line">      &#125;,</span><br><span class="line">      "skuDefaultImg":&#123;</span><br><span class="line">        "type": "keyword",</span><br><span class="line">        "index": false</span><br><span class="line">      &#125;,</span><br><span class="line">      "hotScore":&#123;</span><br><span class="line">        "type": "double"</span><br><span class="line">      &#125;,</span><br><span class="line">      "productId":&#123;</span><br><span class="line">        "type": "keyword"</span><br><span class="line">      &#125;,</span><br><span class="line">      "skuAttrValueList":&#123;</span><br><span class="line">        "properties": &#123;</span><br><span class="line">          "attrId":&#123;</span><br><span class="line">            "type":"keyword"</span><br><span class="line">          &#125;,</span><br><span class="line">          "valueId":&#123;</span><br><span class="line">            "type":"keyword"</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">     &#125; </span><br><span class="line">   &#125;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查数据"><a href="#查数据" class="headerlink" title="查数据"></a>查数据</h1><p>term：过滤条件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">GET /gmallpms/PmsSkuInfo/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "bool": &#123;</span><br><span class="line">      "filter": [</span><br><span class="line">        &#123;</span><br><span class="line">        "term": &#123;</span><br><span class="line">          "price": "1000"</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          "term":&#123;</span><br><span class="line">            "PmsSkuAttrValueList.valueId":"51"</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;],</span><br><span class="line">      "must": [</span><br><span class="line">        &#123;</span><br><span class="line">          "match": &#123;</span><br><span class="line">            "skuName": "小米"</span><br><span class="line">                    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;p&gt;跳过&lt;/p&gt;
&lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="项目" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="毕设" scheme="http://yoursite.com/tags/%E6%AF%95%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>2020-05-11   graduation问题</title>
    <link href="http://yoursite.com/2020/06/07/npm%E6%9B%B4%E6%96%B0%E6%8F%92%E4%BB%B6%20/"/>
    <id>http://yoursite.com/2020/06/07/npm%E6%9B%B4%E6%96%B0%E6%8F%92%E4%BB%B6%20/</id>
    <published>2020-06-07T14:57:52.000Z</published>
    <updated>2020-06-07T15:09:15.156Z</updated>
    
    <content type="html"><![CDATA[<p>就是想更新到最新版本啊！！！</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><ol><li>npm update</li><li>安装 npm-check-updates 模块升级插件</li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> install -g <span class="built_in">npm</span>-check-updates</span><br></pre></td></tr></table></figure><p>查看已安装版本</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ncu -v</span></span><br></pre></td></tr></table></figure><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>npm update，只能按照 package.json 中标注的版本号进行更新，升级后不会修改 package.json 中的版本号，需要自己手动修改，比较麻烦。<br>npm-check-updates 升级插件升级后会自动修改 package.json 里的版本号，简单方便。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;就是想更新到最新版本啊！！！&lt;/p&gt;
&lt;h1 id=&quot;方法&quot;&gt;&lt;a href=&quot;#方法&quot; class=&quot;headerlink&quot; title=&quot;方法&quot;&gt;&lt;/a&gt;方法&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;npm update&lt;/li&gt;
&lt;li&gt;安装 npm-check-updates 模
      
    
    </summary>
    
    
      <category term="项目" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="毕设" scheme="http://yoursite.com/tags/%E6%AF%95%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>2020-05-11   graduation问题</title>
    <link href="http://yoursite.com/2020/06/07/homebrew%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90%EF%BC%88%E8%BD%AC%EF%BC%89/"/>
    <id>http://yoursite.com/2020/06/07/homebrew%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90%EF%BC%88%E8%BD%AC%EF%BC%89/</id>
    <published>2020-06-07T14:57:52.000Z</published>
    <updated>2020-06-07T15:08:25.915Z</updated>
    
    <content type="html"><![CDATA[<p>1、定义<br>Homebrew 是一个很方便的包管理器，主要用来管理 mac 操作系统的包，现在也支持 linux 操作系统的包管理。Homebrew 通过 tap 方式定义源，官方默认提供了 brew、homebrew-core 、homebrew-cask 、homebrew-bottles 四个常用的源（仓库），用户也可以通过 tap 定义自己的源。</p><p>在使用 brew install 安装软件的过程中，经常会遇到安装缓慢、卡死的情况，这大多是由于 Homebrew 的默认安装源位于国外，国内访问速度慢造成的，解决这个问题的方法是将安装源替换为国内镜像，常用的国内镜像包括：阿里巴巴开源镜像、中科大镜像、清华镜像等。</p><p>本文的编写目的是简单的介绍四个常用的源（源），以及如何更换为国内镜像实现快速安装软件。</p><p>2、brew<br>说明：Homebrew 源代码仓库。<br>默认地址：<a href="https://github.com/Homebrew/brew.git" target="_blank" rel="noopener">https://github.com/Homebrew/brew.git</a></p><p>3、homebrew-core<br>说明：Homebrew 核心源（仓库），它是 brew install 的默认安装源（仓库）。<br>默认地址：<a href="https://github.com/Homebrew/homebrew-core.git" target="_blank" rel="noopener">https://github.com/Homebrew/homebrew-core.git</a></p><p>4、homebrew-cask<br>说明：homebrew-cask 源（仓库），提供 macOS 应用和大型二进制文件的安装。通常我们在 mac 操作系统上安装图形用户界面软件，系统都会提示“若要安装，请拖动此图标…”。homebrew-cask 扩展了Homebrew，为安装和管理 Atom 和 Google Chrome 之类的图形用户界面应用程序带来了优雅、简单和速度。</p><p>默认地址：<a href="https://github.com/Homebrew/homebrew-cask.git" target="_blank" rel="noopener">https://github.com/Homebrew/homebrew-cask.git</a></p><p>5、homebrew-bottles<br>说明：Homebrew 预编译二进制软件包。<br>默认地址：<a href="https://bintray.com/homebrew/bottles" target="_blank" rel="noopener">https://bintray.com/homebrew/bottles</a></p><p>6、替换为国内镜像源<br>我的习惯是创建 change_brew.sh 文件，然后在文件中写入替换源需要的命令。以替换为中科大镜像为例，在 change_brew.sh 文件中写入如下内容，并执行该脚本，就可以成功切换镜像源。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换brew.git:</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$(brew --repo)</span>"</span></span><br><span class="line">git remote <span class="built_in">set</span>-url origin https://mirrors.ustc.edu.cn/brew.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换homebrew-core.git:</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core"</span></span><br><span class="line">git remote <span class="built_in">set</span>-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换homebrew-cask.git:</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-cask"</span></span><br><span class="line">git remote <span class="built_in">set</span>-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用生效</span></span><br><span class="line">brew update</span><br><span class="line"><span class="comment"># 替换homebrew-bottles:</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles'</span> &gt;&gt; ~/.bash_profile</span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure><p>通过<code>brew config</code> 命令查看配置信息：</p><p>7、还原默认镜像源<br>创建 restore_brew.sh 文件，写入如下内容，执行该文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换brew.git:</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$(brew --repo)</span>"</span></span><br><span class="line">git remote <span class="built_in">set</span>-url origin https://github.com/Homebrew/brew.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换homebrew-core.git:</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core"</span></span><br><span class="line">git remote <span class="built_in">set</span>-url origin https://github.com/Homebrew/homebrew-core.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换homebrew-cask.git:</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-cask"</span></span><br><span class="line">git remote <span class="built_in">set</span>-url origin https://github.com/Homebrew/homebrew-cask.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用生效</span></span><br><span class="line">brew update</span><br></pre></td></tr></table></figure><p>执行完 restore_brew.sh 文件后，将 ~/.bash_profile 文件中的 HOMEBREW_BOTTLE_DOMAIN=<a href="https://mirrors.ustc.edu.cn/homebrew-bottles&#39;" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/homebrew-bottles&#39;</a> 内容删除，并执行 source ~/.bash_profile，就恢复了默认的镜像。</p><p>8、常见的国内镜像<br>阿里巴巴开源镜像<br>清华镜像<br>中科大镜像</p><p>9、参考资料<br>homebrew github<br>brew github<br>homebrew-core github<br>homebrew-cask github<br>homebrew-bottles<br>Homebrew 的关键词定义</p><p>文章内容仅代表个人观点，如有不正之处，欢迎批评指正，谢谢大家。<br>————————————————<br>版权声明：本文为CSDN博主「志波同学」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/claram/java/article/details/101577547" target="_blank" rel="noopener">https://blog.csdn.net/claram/java/article/details/101577547</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、定义&lt;br&gt;Homebrew 是一个很方便的包管理器，主要用来管理 mac 操作系统的包，现在也支持 linux 操作系统的包管理。Homebrew 通过 tap 方式定义源，官方默认提供了 brew、homebrew-core 、homebrew-cask 、home
      
    
    </summary>
    
    
      <category term="项目" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="毕设" scheme="http://yoursite.com/tags/%E6%AF%95%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>2020-05-11   graduation问题</title>
    <link href="http://yoursite.com/2020/06/07/http%E8%AF%B7%E6%B1%82%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%B8%A6%E4%B8%8Acookie%E4%BF%A1%E6%81%AF/"/>
    <id>http://yoursite.com/2020/06/07/http%E8%AF%B7%E6%B1%82%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%B8%A6%E4%B8%8Acookie%E4%BF%A1%E6%81%AF/</id>
    <published>2020-06-07T14:57:52.000Z</published>
    <updated>2020-06-07T15:08:30.285Z</updated>
    
    <content type="html"><![CDATA[<p>在复习授权验证的时候看到JavaGuide上面说：</p><blockquote><p>使用session做登录验证的时候，别人通过cookie拿到了你的sessionId就假冒你登录网站，为什么使用token以后就不会有这个问题？点击了非法请求，这个非法请求不会携带token？</p></blockquote><p>百度了一下—-&gt;</p><p>Set-Cookie响应头字段（Response header）是服务器发送到浏览器或者其他客户端的一些信息，一般用于登陆成功的情况下返回给客户端的凭证信息，然后下次请求时会带上这个cookie，这样服务器端就能知道是来自哪个用户的请求了。</p><p>Cookie请求头字段是客户端发送请求到服务器端时发送的信息（满足一定条件下浏览器自动完成，无需前端代码辅助）。</p><p>下表为Set-Cookie响应头可以设置的属性</p><table><thead><tr><th align="center">–</th><th align="center">–</th></tr></thead><tbody><tr><td align="center">NAME=VALUE</td><td align="center">赋予 Cookie 的名称和其值（必需项）</td></tr><tr><td align="center">expires=DATE</td><td align="center">Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）</td></tr><tr><td align="center"><font color=red>path=PATH</font></td><td align="center">将服务器上的文件目录作为Cookie的适用对象（若不指定则默<br/>认为文档所在的文件目录）</td></tr><tr><td align="center"><font color=red>domain=域名</font></td><td align="center">作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie<br/>的服务器的域名）</td></tr><tr><td align="center"><font color=red>Secure</font></td><td align="center">仅在 HTTPS 安全通信时才会发送 Cookie</td></tr><tr><td align="center">HttpOnly</td><td align="center">加以限制， 使 Cookie 不能被 JavaScript 脚本访问请看上面标红的三个属性，拿一个Http POST请求来说  <a href="http://aaa.www.com/xxxxx/list" target="_blank" rel="noopener">http://aaa.www.com/xxxxx/list</a></td></tr></tbody></table><p>如果满足下面几个条件：</p><p>1、浏览器端某个Cookie的domain字段等于aaa.<a href="http://www.com或者www.com" target="_blank" rel="noopener">www.com或者www.com</a></p><p>2、都是http或者https，或者不同的情况下Secure属性为false</p><p>3、要发送请求的路径，即上面的xxxxx跟浏览器端Cookie的path属性必须一致，或者是浏览器端Cookie的path的子目录，比如浏览器端Cookie的path为/test，那么xxxxxxx必须为/test或者/test/xxxx等子目录才可以</p><p>注：</p><p>上面3个条件必须同时满足，否则该Post请求就不能自动带上浏览器端已存在的Cookie<br>————————————————<br>版权声明：本文为CSDN博主「PolarisHuster」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/john1337/java/article/details/104571244" target="_blank" rel="noopener">https://blog.csdn.net/john1337/java/article/details/104571244</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在复习授权验证的时候看到JavaGuide上面说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用session做登录验证的时候，别人通过cookie拿到了你的sessionId就假冒你登录网站，为什么使用token以后就不会有这个问题？点击了非法请求，这个非法请求不会携带t
      
    
    </summary>
    
    
      <category term="项目" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="毕设" scheme="http://yoursite.com/tags/%E6%AF%95%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>2020-05-11   graduation问题</title>
    <link href="http://yoursite.com/2020/06/07/linux%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    <id>http://yoursite.com/2020/06/07/linux%E9%98%B2%E7%81%AB%E5%A2%99/</id>
    <published>2020-06-07T14:57:52.000Z</published>
    <updated>2020-06-07T15:08:47.648Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>第一次写分布式商城项目</p><p>在linux上面安装了zookeeper以后</p><p>在项目上注册service出现</p><blockquote><p>connection confused //////</p><p>Session 0x0 for server null, unexpected error, closing socket connection and attempting reconnect</p></blockquote><p>上网查了说很有可能是linux防火墙的原因</p><h1 id="那么防火墙到底是啥呢？？"><a href="#那么防火墙到底是啥呢？？" class="headerlink" title="那么防火墙到底是啥呢？？"></a>那么防火墙到底是啥呢？？</h1><p>2020-02-27提出该疑问—简单百度了解一下先</p><blockquote><p>帮助计算机网络于其内、外网之间构建一道相对隔绝的保护屏障，以保护用户资料与信息安全性的一种技术</p></blockquote><blockquote><p><a href="https://baike.baidu.com/item/防火墙" target="_blank" rel="noopener">防火墙</a>对流经它的网络<a href="https://baike.baidu.com/item/通信" target="_blank" rel="noopener">通信</a>进行<a href="https://baike.baidu.com/item/扫描" target="_blank" rel="noopener">扫描</a>，这样能够<a href="https://baike.baidu.com/item/过滤" target="_blank" rel="noopener">过滤</a>掉一些攻击，以免其在目标<a href="https://baike.baidu.com/item/计算机" target="_blank" rel="noopener">计算机</a>上被执行。<a href="https://baike.baidu.com/item/防火墙" target="_blank" rel="noopener">防火墙</a>还可以关闭不使用的端口。而且它还能禁止特定端口的流出<a href="https://baike.baidu.com/item/通信" target="_blank" rel="noopener">通信</a>，封锁<a href="https://baike.baidu.com/item/特洛伊木马" target="_blank" rel="noopener">特洛伊木马</a>。最后，它可以禁止来自特殊站点的访问，从而防止来自不明入侵者的所有<a href="https://baike.baidu.com/item/通信" target="_blank" rel="noopener">通信</a>。</p></blockquote><p>现在我能想到的问题还只是</p><p>做项目的时候访问dubbo的端口2181被拒绝了，是不是该端口被关闭了的意思？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">256  systemctl status firewalld.service</span><br><span class="line">257  systemctl stop firewalld.service</span><br><span class="line">258  systemctl status firewalld.service</span><br></pre></td></tr></table></figure><p>在我关闭了contos7的防火墙功能以后，项目就可以正常注册服务了。下次遇到再研究吧</p><h1 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h1><p>redis等服务启动后，外网默认是无法访问的，因为防火墙不允许，所以要开启防火墙，让其可以访问这些端口号。</p><p>方法一：使用firewall<br>1、运行命令：<br>firewall-cmd –get-active-zones<br>运行完成之后，可以看到zone名称，如下：</p><p>2、执行如下命令命令：</p><p>firewall-cmd –zone=public –add-port=6379/tcp –permanent</p><p>3、重启防火墙，运行命令：<br>firewall-cmd –reload</p><p>4、查看端口号是否开启，运行命令：<br>firewall-cmd –query-port=6379/tcp</p><p>方法二：使用iptables<br>1、先运行如下命令：</p><p>/sbin/iptables -I INPUT -p tcp –dport xxx -j ACCEPT</p><p>2、然后运行：</p><p>/etc/rc.d/init.d/iptables save </p><p>或者这个命令：</p><p>1、-A INPUT -m state –state NEW -m tcp -p tcp –dport xxx -j ACCEPT </p><p>2、在运行这个命令：</p><p>-A INPUT -j REJECT –reject-with icmp-host-prohibited</p><p>注：xxx ——表示你要开启的端口号，如：6379</p><p>测试：在windows下按下win+R键，输入cmd，运行命令(需开启telnet)，如果变成空界面表示成功：</p><pre><code>telnet  192.168.xx.xx 6379</code></pre><p>————————————————<br>版权声明：本文为CSDN博主「小布吉岛」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/zx110503/article/details/78787483" target="_blank" rel="noopener">https://blog.csdn.net/zx110503/article/details/78787483</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;第一次写分布式商城项目&lt;/p&gt;
&lt;p&gt;在linux上面安装了zookeeper以后&lt;/p&gt;
&lt;p&gt;在项目上注册service出现&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="项目" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="毕设" scheme="http://yoursite.com/tags/%E6%AF%95%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>2020-05-11   graduation问题</title>
    <link href="http://yoursite.com/2020/06/07/mac%20%E6%A0%BC%E5%BC%8F%E5%8C%96ext4u%E7%9B%98/"/>
    <id>http://yoursite.com/2020/06/07/mac%20%E6%A0%BC%E5%BC%8F%E5%8C%96ext4u%E7%9B%98/</id>
    <published>2020-06-07T14:57:52.000Z</published>
    <updated>2020-06-07T15:08:58.412Z</updated>
    
    <content type="html"><![CDATA[<ol><li>安装Homebrew</li><li>安装e2fsprogs</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install e2fsprogs</span><br></pre></td></tr></table></figure><ol start="3"><li>查找盘符</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diskutil list</span><br></pre></td></tr></table></figure><ol start="4"><li>格式化</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">diskutil unmountdisk /dev/disk2</span><br><span class="line">sudo $(brew --prefix e2fsprogs)/sbin/mkfs.ext4 /dev/disk2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;安装Homebrew&lt;/li&gt;
&lt;li&gt;安装e2fsprogs&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;
      
    
    </summary>
    
    
      <category term="项目" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="毕设" scheme="http://yoursite.com/tags/%E6%AF%95%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>2020-05-11   graduation问题</title>
    <link href="http://yoursite.com/2020/06/07/macOS%20%E4%BD%BF%E7%94%A8%20/"/>
    <id>http://yoursite.com/2020/06/07/macOS%20%E4%BD%BF%E7%94%A8%20/</id>
    <published>2020-06-07T14:57:52.000Z</published>
    <updated>2020-06-07T15:09:02.299Z</updated>
    
    <content type="html"><![CDATA[<p>自从一时头脑发热换了 air 到现在也用了一年了,现在重新记录一下使用—心得?技巧?</p><h1 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h1><h2 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h2><p>已经习惯了双拼啦</p><ul><li>长按 caps lock 锁定大写字母,再按一下即可取消</li><li>笔画输入,点击输入法图标或者按 U (大写哦) —这个不懂,没用过</li><li>选择文字注音 输入字母后按 tab 比如 ā,á,ǎ,à</li><li>中英文数字混输,在输入时，按住 Shift 就能输大写字母，按住 Option 则能输数字</li><li>拆字输入,我们输入两个汉字的拼音后，按下「Shift+空格键」就能看到可组合的汉字。比如输入 jiji 后按下组合键即可显示出「喆」字</li><li>查找输入码,点击输入法图标，选择「查找输入码」，或按「Option+Shift+L」即可打开输入码搜索框</li><li>手写输入,在工具栏中点输入法图标，选择「显示手写输入」，或按「Control+Shift+空格键」即可打开手写输入窗口。<strong><em>????为什么我没找到\</em></strong></li><li>虚拟键盘,好像没快捷键?反正我没用过这个</li><li>Emoji、特殊符号与颜文字 shift + option + B</li></ul><h2 id="程序篇"><a href="#程序篇" class="headerlink" title="程序篇"></a>程序篇</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;自从一时头脑发热换了 air 到现在也用了一年了,现在重新记录一下使用—心得?技巧?&lt;/p&gt;
&lt;h1 id=&quot;系统设置&quot;&gt;&lt;a href=&quot;#系统设置&quot; class=&quot;headerlink&quot; title=&quot;系统设置&quot;&gt;&lt;/a&gt;系统设置&lt;/h1&gt;&lt;h2 id=&quot;输入法&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="项目" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="毕设" scheme="http://yoursite.com/tags/%E6%AF%95%E8%AE%BE/"/>
    
  </entry>
  
</feed>
